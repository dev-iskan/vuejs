 для того чтобы подключить Vue можно использовать CDN добавляем его в скрипты:
<script src="https://unpkg.com/vue@2.5.16/dist/vue.js"></script>
с сайта unpkg всегда самые новейшие обновления

Чтобы инициализоровать Vue достаточно создать переменную и присвоить ей обьект Vue()
в него передаем несколько обязательных параметров:
1 - element - элемент который мы привяжем с Vue
2 - обьект data внутри которого можем добавялть любые данные:
    var app = new Vue({
        el:'#app',
        data: {
            message: 'Hello Vue!'
        }
    });
использовать данные vue можно через {{}} как в blade:
    <div id="app">
        <h1>{{message}}</h1>
    </div>





урок 2  Directive{
Директивы — это специальные атрибуты с префиксом v-.
В качестве значения такие атрибуты принимают одно выражение JavaScript (за исключением v-for, о которой ниже).
 Директива реактивно применяет к DOM изменения при обновлении значения этого выражения.

 v-text="variable" - данная директивы будет отображать значение переменной
 v-html = "var" - директива по функции похожа на .innerHtml у js
 разница между двумя этими директивами в том что v-text - не отображает html теги

v-show="var" - данная директива будет показаывать элемент, если переменная равна true, если false то скроет данный элемент, по факту он меняет параметр CSS : display:none, inline  и т.д.:
 true: <h1>You have viewed this page</h1>
 false:<h1 style="display: none;">You have viewed this page</h1>
v-if="var" - похожа на v-show, но разница в том что данная директива удаляет из DOM элемент:
 true: <h1>You have viewed this page</h1>
 false: <!---->
в них можно прописывать более тяжелую логику чем просто true, false:
    v-if="viewed == viewed2"
v-else  соответственно покажет при не сработанном v-if

v-pre - директива которая говорит Vue.js не рендерить данны элемент:
 <h1 v-pre>{{message}}</h1> - то есть с директивой v-pre на экран выведится в таком виде: {{message}}

 v-once - рендерить только один раз, то есть
  <h1 v-once>{{message}}</h1>  - будет сгенерировано один раз, а если мы будем изменять message на ходу, то все равно в данном элементе изменения не будут отображены

v-cloak - Эта директива останется на элементе до тех пор, пока связанный с ним экземпляр Vue не закончит компиляцию.
В сочетании с CSS-правилом [v-cloak] { display: none } этой директивой можно скрывать нескомпилированные шаблоны до тех пор, пока экземпляр Vue не будет готов.

}


урок 3 Директива v-bind {
Сокращение: :
Принимает: any (если указан параметр) | Object (если параметр не указан)
Параметр: attrOrProp (опционально)
Модификаторы:
.prop — используется для связывания в качестве DOM-свойства, а не атрибута (в чём разница?). Если тег является компонентом, то .prop будет устанавливать свойство на $el компонента.
.camel — (2.1.0+) преобразует имена атрибутов из kebab-case в camelCase.
.sync — (2.3.0+) синтаксический сахар, который будет преобразован в обработчик v-on для обновления связанного значения.
Использование:
Динамически связывает атрибуты тега или входной параметр компонента с выражением.
При использовании с атрибутами class и style поддерживает массивы и объекты в качестве значений. Подробнее это описано в соответствующем руководстве по ссылке ниже.
Для правильного связывания входного параметра компонента, тот должен быть корректно определён в дочернем компоненте.
Если аргумент не указан, связанное значение может быть содержащим пары имя-значение. Обратите внимание, что в этом случае атрибуты class и style не поддерживают массивы и объекты.

<img :src="url" :alt="title"> - таким образом мы биндим аттрибут src к url переменной
}



урок 4 v-for {
Принимает: Array | Object | number | string

Использование:

Многократно рендерит элемент или блок шаблона, основываясь на переданных данных. Значение директивы должно следовать синтаксису alias in expression — в alias будет элемент текущей итерации:

<div v-for="item in items">
  {{ item.text }}
</div>
Кроме того, вы можете указать название для индекса (или ключа, если вы работаете с объектом):

<div v-for="(item, index) in items"></div>
<div v-for="(val, key) in object"></div>
<div v-for="(val, key, index) in object"></div>
По умолчанию v-for будет пытаться обновить элементы “на месте”, не перемещая их. Если вам
}



урок 5 2-way binding{
v-model ="variable"
Принимает: разное, в зависимости от типа форм или выходных данных компонентов

Используется только с:

<input>
<select>
<textarea>
компонентами
Модификаторы:

.lazy — подписаться на события change, а не input
.number — приводить введённую строку к числу
.trim — удалять пробелы в начале и в конце введённой строки
Использование:

Двусторонним образом связывает элемент ввода данных или компонент с переменной. Директива подробно описана в руководстве по ссылке ниже.

<input type="text" v-model="message">
}



урок 6 events{
    v-on    Сокращение: @

    Принимает: Function | Inline-выражение | Object

    Параметр: event

    Модификаторы:

    .stop — вызовет event.stopPropagation().
    .prevent — вызовет event.preventDefault().
    .capture — добавит подписку в режиме capture.
    .self — вызовет обработчик только если событие возникло непосредственно на этом элементе.
    .{keyCode | keyAlias} — вызывает обработчик только при нажатии определённой клавиши.
    .native — подписаться на нативное событие на корневом элементе компонента.
    .once — вызовет обработчик не больше одного раза.
    .left - (2.2.0) вызов обработчика только по событию нажатия левой кнопки мыши.
    .right - (2.2.0) вызов обработчика только по событию нажатия правой кнопки мыши.
    .middle - (2.2.0) вызов обработчика только по событию нажатия средней кнопки мыши.
    .passive - (2.3.0+) вызов обработчика события DOM с опцией { passive: true }.
    Использование:

    Прикрепляет к элементу подписчик события. Тип события указывается в параметре. Выражение может быть именем метода, inline-выражением или вовсе отсутствовать, если указан один или несколько модификаторов.

    У обычного элемента можно подписаться только на нативные события DOM. У элемента компонента можно подписаться на пользовательские события, вызываемые этим дочерним компонентом.

    При работе с нативными событиями DOM, метод получает нативное событие единственным аргументом. В inline-выражениях, можно получить к нему доступ с помощью $event: v-on:click="handle('ok', $event)".

    Начиная с версии 2.4.0+, v-on также поддерживает привязку к объекту пар событие/обработчик без аргумента. Обратите внимание, что при использовании синтаксиса объекта не поддерживаются никакие модификаторы.

    все события во vue регистрирутся через директиву v-on:event="method" (click, keydown)
    все методы регистрируются в обьекте vue в свойстве methods:

    var app = new Vue({
        el:'#app',
        data: {
            message: 'Hello Vue!'
        },
        methods: {
             countUp: function () {
                this.count += 1
             },
        }
    });
}


урок 8 computed properties{
Выражения, встраиваемые в шаблоны, удобны, но предназначены они только для простых операций.
При усложнении логики, они быстро становятся трудноподдерживаемыми. Например:

<div id="example">
  {{ message.split('').reverse().join('') }}
</div>
Этот шаблон уже не выглядит просто и декларативно.
С первого взгляда и не скажешь, что он всего лишь отображает message задом наперёд.
Ситуация станет ещё хуже, если эту логику в шаблоне потребуется использовать в нескольких местах.

На помощь приходят вычисляемые свойства.

Простой пример
<div id="example">
  <p>Изначальное сообщение: "{{ message }}"</p>
  <p>Сообщение задом наперёд: "{{ reversedMessage }}"</p>
</div>
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Привет'
  },
  computed: {
    // геттер вычисляемого значения
    reversedMessage: function () {
      // `this` указывает на экземпляр vm
      return this.message.split('').reverse().join('')
    }
  }
})
Результат:
Изначальное сообщение: "Привет"
Сообщение наоборот: "тевирП"

Здесь мы определили вычисляемое свойство reversedMessage. Написанная нами функция будет использоваться как геттер свойства vm.reversedMessage:

console.log(vm.reversedMessage) // => 'тевирП'
vm.message = 'Пока'
console.log(vm.reversedMessage) // => 'акоП'
Вы можете открыть консоль и поиграть с примером сами. Значение vm.reversedMessage всегда зависит от значения vm.message.

В шаблонах вы можете привязываться к вычисляемым свойствам ровно таким же образом, как и к обычным.
 Vue знает, что vm.reversedMessage зависит от vm.message, так что при обновлении vm.message обновятся и все элементы, зависящие от vm.reversedMessage.
 И самое главное, что эту зависимость мы указали декларативно: геттер вычисляемого свойства не имеет побочных эффектов, что упрощает как понимание кода, так и тестирование.
}


урок 8, computed setters and getters{

разница между методами и computed properties в том что vuejs кеширует computed properties так что в при обьявлении нового обьекта
и использовании того же computed property vue просто возьмет с кеша сохраненные значения.


computed properties созданы для того чтобы их подключать к getters and setters

по умолчанию мы работаем с геттером
 fullname: function() {
                return this.first + " " + this.last
 }

чтобы создать setter нужно распределить computed properties на get и set, также есть input для fullname:
<label>Full Name:</label>
<input type="text" class="form-control" v-model="fullname" />

 fullname: {
                //getter getting fullname as combination of first and last name
                get: function () {
                    return this.first + " " + this.last;
                },
                //setter setting first and lastname be changing computed properties input
                set: function (fullname) {
                    var name = fullname.split(' ');
                    this.firstName=name[0];
                    this.lastName=name[name.length-1];
                }
            }

По умолчанию вычисляемые свойства работают только на чтение, но в случае необходимости вы можете также указать и сеттер:

// ...
computed: {
  fullName: {
    // геттер:
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // сеттер:
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
Теперь запись vm.fullName = 'Иван Иванов' вызовет сеттер, и vm.firstName и vm.lastName будут соответствующим образом обновлены.
}


урок 10 AJAX {
watch
Тип: { [key: string]: string | Function | Object | Array }

Подробности:

Объект, ключи которого — выражения для наблюдения, а значения — коллбэки, вызываемые при их изменении. Значения также могут быть строками с именами методов, или объектами, содержащими дополнительные опции. Экземпляр Vue вызовет $watch() соответствующий каждому ключу объекта при своём создании.

Пример:

var vm = new Vue({
  data: {
    a: 1,
    b: 2,
    c: 3,
    d: 4,
    e: {
      f: {
        g: 5
      }
    }
  },
  watch: {
    a: function (val, oldVal) {
      console.log('новое значение: %s, старое значение: %s', val, oldVal)
    },
    // строка с именем метода:
    b: 'someMethod',
    // глубокий (рекурсивный) наблюдатель:
    c: {
      handler: function (val, oldVal) { /* ... */ },
      deep: true
    },
    // коллбэк будет вызван сразу же после начала наблюдения
    d: {
      handler: function (val, oldVal) { /* ... */ },
      immediate: true
    },
    e: [
      function handle1 (val, oldVal) { /* ... */ },
      function handle2 (val, oldVal) { /* ... */ }
    ],
    // отслеживание значения `vm.e.f`: {g: 5}
    'e.f': function (val, oldVal) { /* ... */ }
  }
})
vm.a = 2 // => новое значение: 2, старое значение: 1
Обратите внимание, что вам не стоит использовать стрелочные функции при определении наблюдателей
 (напр. searchQuery: newValue => this.updateAutocomplete(newValue)).
 Поскольку стрелочные функции связываются с родительским контекстом,
 this не будет указывать на экземпляр Vue, и this.updateAutocomplete окажется неопределённым.



нужно отправлять после написания 5 символов, для этого используется свойство watch у vuejs:
в нем мы пропишем что пока не набраны 5 символов, startingCity будет пустой строкой, далее идет проверка и вызов метода
который будет отправлять api запрос:
 startingZip: function () {
                this.startingCity = '';
                if(this.startingZip.length==5){
                    //call API
                    this.lookupStartingZip();
                }
            }

 далее  метод lookupStartingZip () должен вызвать методы axios которые непосрелственно будут отправлять запрос API,
 после получения данных мы приравниваем их к нашему startingCity:
 lookupStartingZip: _.debounce(function () {
                 var vm =this;//vue model
                 vm.startingCity = "Searching...";
                 //API request
                 axios.get('http://ziptasticapi.com/' + vm.startingZip)
                     .then(function (response) {
                     vm.startingCity = response.data.city + ', ' + response.data.state;
                 })
                     .catch(function (error) {
                         vm.startingCity="Invalid Zipcode";
                     });
             }, 500),

 тут также используется метод _debounce(function, delay) - суть которого в том что он позволяет вызвать определенный метод
 через определенное количество миллисекунд, это нужно для того чтобы не произошли не предвиденные изменения, плюс для лучшего UI
 мы сначала пропишем в startingCity значение Searching..., чтобы пока идет запрос пользователь видел что что-то будет изменяться
}

















webformyself
v-html директива позволяет выводить и компилировать html код который может храниться как переменная

@click = "myFunction()" - возможность передавать функцие обаботчика событий
если мы хотим передать событие, то используем вот такой вот синтаксис:
@click = "myFunction($event)" - то есть $event зарезервированное имя для передачи события, можно включать не смотря на порядок

модификаторы события - это дополнительная возможность у директивы v-on, которая позволяет уменьшить код:
@click.prevent="testFunction()" - здесь prevent это модификатор
@mousemove.stop=" " - stop это укороченное название stopPropagation  которое останавливает обаботчик события
<!-- событие click не будет всплывать дальше -->
<a v-on:click.stop="doThis"></a>

<!-- событие submit больше не будет перезагружать страницу -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- модификаторы можно объединять в цепочки -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- и использовать без указания пользовательского обработчика -->
<form v-on:submit.prevent></form>

<!-- при добавлении слушателя события можно использовать capture mode -->
<!-- т.е. событие, нацеленное на внутренний элемент, обрабатывается здесь до обработки этим элементом -->
<div v-on:click.capture="doThis">...</div>

<!-- вызывать обработчик только в случае наступления события непосредственно -->
<!-- на данном элементе (то есть не на дочернем компоненте) -->
<div v-on:click.self="doThat">...</div>


у клавиатуры модификаторы таковы:
@keyup.enter.space./// = "myFunction", в данном случае данные модификаторы разряшают или запрещают обработку события пока не будет нажата данная клавиша
.enter
.tab
.delete (ловит как “Delete”, так и “Backspace”)
.esc
.space
.up
.down
.left
.right

также можно создать пользовательские клавиши:
// позволит использовать `v-on:keyup.f1`
Vue.config.keyCodes.f1 = 112, где 112 это keyCode у f1

Модификаторы формы:
<!-- синхронизируется после "change", а не "input" -->
<input v-model.lazy="msg" >



Классы:
Для динамического задания или удаления CSS-классов мы можем передать в директиву v-bind:class объект:

<div v-bind:class="{ active: isActive }"></div>
Запись выше обозначает, что наличие класса active будет определяться истинностью параметра isActive.

Таким образом можно управлять несколькими классами, добавляя в объект дополнительные поля. Кроме того, v-bind:class можно использовать и совместно с обычным атрибутом class:

<div class="static"
     v-bind:class="{ active: isActive, 'text-danger': hasError }">
</div>

При использовании этих данных:
data: {
  isActive: true,
  hasError: false
}

В v-bind:class можно передать и массив:

<div v-bind:class="[activeClass, errorClass]"></div>
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}


Для переключения классов, переданных в массиве, в зависимости от некоторого условия, можно использовать тернарный оператор:

<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
В этом случае errorClass будет применён к элементу всегда, а activeClass — только в случае истинности isActive.

Однако, такая запись становится слегка громоздкой, если у вас есть несколько классов, задаваемых по условию. Поэтому можно использовать и смешанный синтаксис:

<div v-bind:class="[{ active: isActive }, errorClass]"></div>


Inline стили:
Объектная запись для v-bind:style довольно проста — выглядит почти как CSS, хотя, на самом деле, это объект JavaScript. Для указания свойств CSS можно применять как camelCase, так и kebab-case (не забывайте про кавычки при использовании kebab-case):

<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
data: {
  activeColor: 'red',
  fontSize: 30
}
Передача объекта стилей по имени нередко может сделать код чище:

<div v-bind:style="styleObject"></div>
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
Разумеется, можно использовать и вычисляемые свойства, возвращающие объекты стилей.

Использование массивов
Запись v-bind:style с массивом позволяет применить несколько объектов стилей к одному и тому же элементу:

<div v-bind:style="[baseStyles, overridingStyles]"></div>


Условный рендеринг:
Как следует из названия, v-else-if служит в качестве “блока else if” для директивы v-if. Можно объединять эти директивы в длинные цепочки:

<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Не A/B/C
</div>
Подобно v-else, v-else-if должен непосредственно следовать за элементом с v-if или v-else-if.


v-if в сравнении с v-show
v-if производит “настоящий” условный рендеринг, удостоверяясь что подписчики событий и дочерние компоненты внутри блока должным образом уничтожаются и воссоздаются при изменении истинности управляющего условия.
v-if также ленив: если условие ложно на момент первоначального рендеринга, он не произведёт никаких действий — условный блок не будет отображён, пока условие впервые не станет истинным.
v-show, напротив, куда проще: элемент всегда присутствует в DOM, и только CSS-свойство переключается в зависимости от значения выражения.
В целом у v-if выше затраты на переключения, а у v-show более высокие затраты на первичный рендеринг. Так что если вы предполагаете, что переключения будут частыми, используйте v-show, если же редкими или вовсе маловероятными — v-if.





Внутри блока v-for нам полностью доступны свойства из области видимости родителя. v-for также поддерживает необязательный второй параметр для указания индекса текущего элемента.

<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Родитель',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})


v-for для объекта
v-for можно также использовать для итерирования по свойствам объекта:

<ul id="v-for-object" class="demo">
  <li v-for="value in object">
    {{ value }}
  </li>
</ul>
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      firstName: 'Иван',
      lastName: 'Петров',
      age: 30
    }
  }
})

Можно также указать второй аргумент для получения ключей:

<div v-for="(value, key) in object">
  {{ key }}: {{ value }}
</div>

И третий — для индексов:

<div v-for="(value, key, index) in object">
  {{ index }}. {{ key }}: {{ value }}
</div>

Рекомендуем указывать key с v-for по возможности всегда, за исключением случаев, когда итерируемый контент DOM прост, или когда вы сознательно используете стратегию по умолчанию для улучшения производительности.



Ref:
Доступ к экземплярам дочерних компонентов & элементов
Несмотря на наличие входных параметров и событий, иногда вам может потребоваться прямой доступ к дочернему компоненту в JavaScript. Для этого вы можете назначить ссылочный ID дочернему компоненту с помощью атрибута ref. Например:
<base-input ref="usernameInput"></base-input>
Теперь в компоненте, где вы определили этот ref, вы можете использовать:
this.$refs.usernameInput
для доступа к экземпляру <base-input>. Это может быть полезно, если вы хотите например, программно добавить фокус на поле из родителя. В этом случае компонент <base-input> может аналогичным образом использовать ref чтобы обеспечить доступ к определённым элементам внутри него, например:
<input ref="input">
И даже определить методы для использования родителем:
methods: {
  // Используется родителем для фокуса на input
  focus: function () {
    this.$refs.input.focus()
  }
}
Таким образом мы позволим родительскому компоненту добавлять фокус на input внутри <base-input> с помощью:
this.$refs.usernameInput.focus()
Когда ref используется вместе с v-for, то ref будет массивом, содержащим дочерние компоненты, отображаемых от источника данных.
$refs заполняются только после того, как компонент был отрендерен, и они не реактивны. Это подразумевается только как обходной путь для прямого манипулирования потомками — вам следует избегать доступа к $refs из шаблонов или вычисляемых свойств.




ref
Принимает: string
Название элемента или компонента для регистрации ссылки на него. В объекте $refs появится поле с названием из этого атрибута и значением: элементом DOM, если атрибут стоял на простом теге или экземпляром компонента, если атрибут стоял на пользовательском компоненте:
<!-- vm.$refs.p будет DOM-элементом -->
<p ref="p">hello</p>
<!-- vm.$refs.child будет указывать на экземпляр дочернего компонента -->
<child-component ref="child"></child-component>
При использовании на элементах/компонентах с v-for, регистрируется массив ссылок на элементы DOM или экземпляры компонентов.
Важное замечание о времени регистрации ссылок: поскольку ссылки создаются render-функцией, вы не сможете использовать их при первичном рендеринге — на тот момент они ещё не существуют! Кроме того, объект $refs не является реактивным, поэтому не стоит пытаться использовать его в шаблонах для связывания данных.



vm.$refs
Тип: Object
Только для чтения
Подробности:
Объект из DOM-элементов и экземпляров компонентов, зарегистрированных с помощью атрибутов ref.





vm.$mount( [elementOrSelector] )
Аргументы:
{Element | string} [elementOrSelector]
{boolean} [hydrating]
Возвращает: vm — сам экземпляр
Использование:
Если при создании экземпляра Vue не была указана опция el, он окажется в “непримонтированном” (unmounted) состоянии, то есть без ассоциированного элемента DOM. Вызовите vm.$mount(), чтобы примонтировать такой экземпляр.
Если параметр elementOrSelector не указан, шаблон будет отрендерен как элемент вне документа. Вы сможете затем вставить такой элемент нативным интерфейсом DOM.
Метод возвращает сам экземпляр, чтобы вы могли вызывать дополнительные методы по цепочке.
Пример:
var MyComponent = Vue.extend({
  template: '<div>Привет!</div>'
})
// создаём и монтируем в #app (заменит #app):
new MyComponent().$mount('#app')

// другой вариант записи, делает то же самое:
new MyComponent({ el: '#app' })

// рендерим вне документа и вставляем в DOM позднее:
var component = new MyComponent().$mount()
document.getElementById('app').appendChild(component.$el)


template
Тип: string

Подробности:

Строковый шаблон с разметкой для экземпляра Vue. Этот шаблон заменит элемент в точке монтирования. Вся уже существующая разметка в точке монтирования будет проигнорирована, если в шаблоне нет слота распределения контента.

Если строка начинается с #, она будет использована как querySelector, а в качестве строкового шаблона будет использован innerHTML элемента с указанным id. Так вы сможете включать шаблоны, из тегов вроде <script type="x-template">.

С точки зрения безопасности необходимо использовать только те шаблоны Vue, которым вы можете доверять. Никогда не используйте в качестве шаблона данные, вводимые пользователем.

Если в опциях Vue указана render-функция, шаблон будет проигнорирован.




Жизненный цикл:
beforeCreate: function(){
} - вызывается тогда когда происходит инициализация и vue готовится создать новое приложение

created: function(){
} - приложение будет создано

на выше описанных этапах html код еще не был создан

beforeMount: function(){
} - приложение начало анализировать шаблон и собирается вставить скомпилированный шаблон в DOM дерево

mounted: function(){
} - шаблон был вставлен в ДОМ дерево


beforeUpdate: function() {
} - цикл происходит перед изменением чего - либо

updated: function(){
} - цикл происходит после изменения

beforeDestroy: function(){
} - вызывается перед удалением обьекта
сам destroy вызывается через метод this.$destroy()

destroy: function(){
} - после уничтожения




Cli {
чтобы установить cli нужно сначала запустить команды
npm install -g @vue/cli
npm install -g @vue/cli-init

далее
vue init webpack-simple vue-project - где webpack-simple это template, а vue-project это имя проекта



render: - функция которая позволяетс запускать приложение,
внутри App.vue есть ES6 метод export default - который экспортирует обьект со всеми методами vue

}

Компоненты{
    lesson 1 {
        Components are one of the most powerful features of Vue.js.
        They help you extend basic HTML elements to encapsulate reusable code.
        At a high level, Components are custom elements that Vue.js’ compiler would attach specified behavior to.
        In some cases, they may also appear as a native HTML element extended with the special is attribute.

        для того чтобы создать компонент, нужно использовать метод у Vue:
        Vue.component('tag-name', {
            template: ``,
            data: function(){
                return {
                }
            }
        });
        где мы видим первым параметром компонент принимает название тега которвым он будет вызываться, второй параметр
        это обьект инициализации vue
        в нем обязательно должно быть свойство template - это и есть тот шаблон html который будет производиться вместо
        тегов

        data - здесь функция.
    }

    lesson 2 {
        data именно функция т.к. компоненты могут повторяться на странице, но их суть заключается в том что каждый из них должен быть идентичен.
        если мы будем использовать data к функция которая возвращает обьект, то мы получается регистрируем для каждого компонента
        свою персональную функцию которая будет возвращать данные именно для своего компонента. То есть javascript будет создавать новый обьект
        для каждого компонента.

        В случае когда мы используем обьект data то все переменные для этого обьекта будут едины для всех компонентов использующих данный обьект:

        var dataObj= {
            counter: 0
        }

        Vue.component..:
            data: dataObj

        и тогда если мы будем нажимать на кнопку add у разных компонентов, коунтер будет увеличиаваться у всех одновременно, т.к. все компоненты имеют доступ к одной переменной
    }


    lesson 3 {
        существует возможность регистрировать компоненты глобально и локально, в предудыщих 2 уроках мы регистрировали компонент глобально, но тут будем регать локально
        это делается для того чтобы если у нас существуют несколько приложений vue например app и app2, и у них могут быть компоненты с одинаковым названием но разным функционалом
        то глобально созданные компоненты не будут удобны.

        для локального создания мы можем в обьекте vue использовать свойство components :
        components: {
            'my-counter': {
                template: `
                    <div style="border:1px solid black; padding: 10px;">
                      <h2>Counter: {{counter}}</h2>
                      <button @click="add">Add</button>
                    </div>
                 `,
                data: function () {
                    return {
                        counter: 0
                    }
                },
                methods: {
                    add: function () {
                        this.counter++;
                    }
                }
            }
        }

        теперь соответственно в app2 vue не видит такой компонент как my-counter
    }

    lesson 4 {
        название компонентов инициализируется через строку как в уроке выше, но иногда это не возможно, поэтому ткаже возможно называть компоненты
        не в строковом формате, а используя camelCase, а vue сам распарсит и создатся тег в kebab-case:
        el: '#app2',
            components: {
                myCounter: {
                    template: `
                        <div style="border:1px solid black; padding: 10px;">
                          <h2>Counter: {{counter}}</h2>
                          <button @click="add">Add</button>
                        </div>
                     `,
                    data: function () {
                        return {
                            counter: 0
                        }
                    },
                    methods: {
                        add: function () {
                            this.counter++;
                        }
                    }
                }
        }
    }


    lesson 5  {
        переходим в cli vue-project

        создаем компонент Car.vue

        также можно зарегистрировать компоненты глобально и локально:
        глобально: в main.js импортируем данный компонент, и через метод Vue.component() создаем его:
            // import Car from './Car.vue'
            //
            // Vue.component('app-car', Car);

        локально: в App.vue импортируем опять таки компонент и в свойстве components добавляем данный компонент:
            import Car from './Car.vue'

            export default {
                data() {
                    return {
                        msg: 'Welcome'
                    }
                },
                components: {
                    appCar: Car
                }
            }
    }


    lesson 6 {
		чтобы передать какие то переменные в компоненты, мы сначала байндим название переменной к переменной в род компоненте
		у компонента:
		<app-car :carName="carName"></app-car>

		далее в дочернем компоненте добавим свойство props у него покажем что была передана переменная, props принимает
		массив из строк с названием переменных:
		 props: [
                    'carName'
         ],
    }

    lesson 7 {
		валидация передаваемых данных, в vue возможно валидировать данные на тип default, required и т.д.
		допустим мы передаем carName в дочерний компонент car.vue, но случайно он стал цифровым значением, но у нас есть
		в дочернем методе какой то функционал который работает со строками, для этого мы можем валидировать данные:
		создаем не массив, а обьект props у дочернего компонента, и у переменных добавляем обьект:
		props: {
            carName: {
                type: String,
                required: true,
                default: 'Toyota'
            },
            carYear: Number
        },
        как мы видим у carName мы проверяем является ли тип String, required и дефолт значение

        также можно валидировать просто на тип не через обьект а просто прописав как значение
    }

    lesson 8 {
		для того чтобы передать какие то значения или изменения с дочернего в родительский класс, нужно:
		1-сделать emit события у дочернего компонента:
		 <button @click="changeName">Изменить имя</button>
		в скрипте
		methods: {
            changeName: function () {
                this.carName='Mazda';
                this.$emit('nameChanged', this.carName);
            }
        } - тут мы видим что this.$emit('name', param) будет вызывать событие у род класса, и первым параметром принимает название
        события, вторым переменную которую надо передать

        2- нужно прослушивать данное событие у родительского компонента:
        @nameChanged="carName=$event/*changeName($event)*/"
        тут мы прослушиваем событие nameChanged и в нем присваиваем обьекту из род класса carName значение $event,
        которое и есть то самое значение которые передавалось с дочернего компонента
    }


	lesson 9 {
		также можно передавать функции с родительского в дочерний компонент
		для начала создадим метод в родительском App.vue:
		changeName: function () {
            this.carName = 'Audi';
        }

        далее байндим его в дочерний комп:
        :changeFunc="changeName" -  то есть будет создана переменная changeFunc которая будет методом

        проверим ее на валидность в дочернем компоненте в Props:
         changeFunc: Function

        и вызываем ее:
           <button @click="changeFunc">Изменить имя от родителя</button>
	}


	lesson 10 {
		взаимодействие между двумя дочерними компонентами:
		это можно сделать разными способами, тут сначала рассмотрим более сложный:

		допустим мы будем нажимать на кнопку в дочернем комп car и значение counter должно изменяться в counter:
		для этого сначала зарегистрируем новый компонент, далее пропишем в нем template и scripts:
		<template>
            <h1>Counter - {{counter}}</h1>
        </template>

        <script>
        export default {
            props: ['counter']
        }
        </script>

        далее создадим переменную counter в App.vue и будем передавать его в counter и car компоненты:
         <app-counter :counter="counter"></app-counter>
         :counter="counter"

         далее в car.vue пропишем button и method:
          <button @click="updateCounter">Добавить в счетчик</button>

          updateCounter: function () {
              this.$emit('counterUpdated', this.counter+1)
          }

          и соответственно будем прослушивать событие в app.vue:
            @counterUpdated="counter=$event"

			но если честно очень много логики
	}



	lesson 11 {
	проще метод, сначала в main.js созадим константу и будем ее экспортировать:
	export const eventEmiter = new Vue()
	данная переменная нужна как инициализатор события

	импортируем его в Counter.vue и Car.vue:
	import {eventEmitter} from "./main";

	далее в копм. Car изменим метод updateCounter:
	    updateCounter: function () {
            eventEmitter.$emit('counterUpdated', 3);
        }- тут мы также через метод $emit вызываем событие 'counterUpdated' и также можем передать какие то значения вторым параметром

    теперь в комп counter будем прослушивать данное событие:
	    created(){
	        eventEmitter.$on('counterUpdated', (num) => {
	            if(num){
	                this.counter+=num;
	            }
	            else {
	                this.counter++;
	            }
	        })
	    } - тут мы с помощью метода $on прослушиваем событие 'counterUpdated' и ждем получение аттрибута в функции,
	    данная функция как раз и будет выполнять обработчик события
	}



	lesson 12 {
		все стили глобальные и если мы пропишем стиль для одного компонента и также будет использовать такое же название классов или
		стиль по тегам то эти стили будут относиться ко всему шаблону

		чтобы этого избежать достаточно просто добавить такой аттрибут как scoped к style:
		<style scoped>
            h2 {
                color: red;
            }
        </style> - все теперь данный стиль будет относиться только к своему дочернему обьекту
	}

	lesson 13 {
		также в дочерние компоненты мы можем передавать html код для этого мы можем прям внутрь компонента прописать html код App.vue:
		<app-car>
			<h2> Hello </h2>
		</app-car>

		 но для того чтобы дочерний видел мы должны добавить такой тег который vue сам читает Car.vue:
		 <div>
		    <slot></slot>
		 </div>

		 также мы можем с род комп спокойно передавать переменные App.vue:
		  <h2>Mazda + {{carName}}</h2>

		  также все стили прописанные в род комп будут работать для этого html кода в дочернем комп-те
		  и наоборот все дочерние стили будут работать на передаваемом шаблоне от род компа

		  также мы можем определять расположение тех или иных слотов, для этого нужно в Car.vue добавить аттр name:
		   <slot name="h2"></slot>
          <hr>
          <hr>
          <slot name="p"></slot>

          а в App.vue добавить аттр slot:
          <h2 slot="h2">Mazda + {{carName}}</h2>
          <p slot="p">test</p>
	}
  }



  Директивы {
  lesson 1 {
    создание собственной директивы

	для того чтобы создать директиву нужно:
	1 - создаем файл в src в котором будем описывать эту директиву, пример color.js:
	export default {

    }

    2 - импортируем ее в main.js и с помощью метода Vue.directive(name, objectDescription) инициализируем ее:
    import ColorDirective from 'color.js'

    Vue.directive('colored', ColorDirective);
    new Vue({
      el: '#app',
      render: h => h(App)
    })
  }


  lesson 2 {
	директива это обьект, и первый метод при ее инициализации это метод bind(el, bindings, vnode){}
	где el - элемент к которому добавляется директива, bindings - содержит все свойства которые будем передавать внутрь директивы: значение, имя и т.д.
	vnode - обьект хранящий место где будет храниться директива. Последние два параметра readonly:

	сам bind() описываем :
	 bind(el, bindings, vnode) {
            // el.style.color = 'red';
            el.style.color = 'blue';
    }

    и инициализируем директиву внутри vue компонента:
        <h2 v-colored>{{msg}}</h2>
  }


  lesson 3 {
  жизненный цикл:
    bind(el, bindings, vnode) - инициализируется и прикрепляется к виртуальному DOM, но еще не в реальном DOM
    inserted(el, bindings, vnode) - директива уже добавлена в реальное DOM
    update(el, bindings, vnode, oldvnode) - вызывается когда что то происходит внутри DOM дерева
	componentUpdated(el, bindings, vnode, oldvnode) - вызывается сразу после update если были изменены дочерние элементы
	unbind() - когда директива убирается из DOM или прекращает существ
  }

  lesson 4 {
  передача переменных:
	для того чтобы передавать значения в директивы можно просто в кавычках прописать значение:
	<h2 v-colored="'green'">{{msg}}</h2> в нашем случае мы передаем цвет green

	и в цикле bind() получить это значение:
	el.style.color = bindings.value;

	то есть через bindings параметр мы можем получить доступ к переменныи передаваемым в директивы
  }

  lesson 5 {
  передача аргументов директивы:
  аргументом называется вот такая конструкция:
  <button v-on:click> - аргумент идет после : и называется click

	чтобы получить доступ мы в обьекте директивы прописываем:
	 bind(el, bindings, vnode) {
        const argument = bindings.arg; // получаем как раз слово после : background или color
        el.style[argument] = bindings.value;
     },

     и в самом шаблоне:
     <h2 v-colored:background="'green'">{{msg}}</h2>
     <h2 v-colored:color="'blue'">{{msg}}</h2>
  }

  lesson 6 {
    модификаторы:
    <button v-on:click.prevent> - где prevent это и есть модификатор

	создадим в шаблоне такие модификаторы:
	 <h2 v-colored:background.font="'green'">{{msg}}</h2>
        <h2 v-colored:color.delay.font="'blue'">{{msg}}</h2>

    все модификаторы приходят в параметр bindings.modifiers:
   const fontModifier = bindings.modifiers['font']; //так мы получаем модификаторы переданные в директиву, получает либо true либо false

	далее мы проверяем если есть или нет данной переменной мы прописываем логику:
	if(fontModifier){
        el.style.fontSize ='30px'
    }
  }

  lesson 7 {
     локальная инициализация:
     можно инициализировать директивы внутри компонентов через:
     directives: {
		font: {
		bind(el,bindings, vnode){
		el.style.fontSize = '40px'
		}
		}
     }
		так можно инициализировать
     <h2 v-font>Local directive</h2>
  }
  }

Фильтры и миксины{
    Фильтры это специальные трансформеры которые позволяют нам преобразовывать отображение каких либо строк или элементов:

    регистрировать фильтры можно глобально и локально:
    глобально в main.js обращаемся к Vue инстансу и создаем фильтр через метод filter, где первым параметром пишем название
    а вторым мы пишем ФУНКЦИЮ которое получает какое то исходное значение которое нужно будет преобразовать, в нашем случае
    мы преобразуем value в верхний регистр:
    Vue.filter('uppercase', value=>value.toUpperCase());

    для локального создания в свойстве filters создаем функцию опять таки как выше:
    filters: {
    lowercase(value) {
       return value.toLowerCase();
        }
    }

    вызываются фильтры в template через вертикальную черту, где перед чертой то значение которое нужно преобразовать:
    <h1>{{ msg | lowercase }}</h1>
    <h1>{{ msg | uppercase }}</h1>

    также есть возможность применять фильтры несколько раз:
    <h1>{{ msg | uppercase | lowercase}}</h1>

Фильтрация списков:
        для того чтобы фильтровать списки есть достаточно простой способ:

        создаем массив фруктов и стринговое поле search:
         fruits: ['apple', 'banana', 'orange', 'peach'],
        search: ''

        далее отображаем в шаблоне:
        <input type="text" v-model="search">
        <ul>
            <li v-for="fruit in filteredFruits">{{fruit}}</li>
        </ul>

        то есть у нас есть input search в котором мы ищем фрукт и есть список всех фруктов соответствующих поиску,
        но filteredFruits это computed метод, в нем и просходит сравнение и т.д.:
        computed: {
            filteredFruits(){
                return this.fruits.filter(fruit=>{
                    return fruit.toLowerCase().indexOf(this.search.toLowerCase()) !== -1
                })
            }
        }


Миксины:
        Миксины это инстансы vue которые можно использовать для исключения повторения кода, бывают случаи когда код нужно
        дублировать, но вместо тупо копипастинга можно использовать mixin:

        1 - локально: создаем файл listMixin.js и туда вставляем код который хотим чтобы дублировался:
        export default {
            data() {
                return {
                    fruits: ['apple', 'banana', 'orange', 'peach'],
                    search: ''
                }
            },
            computed: {
                filteredFruits(){
                    return this.fruits.filter(fruit=>{
                        return fruit.toLowerCase().indexOf(this.search.toLowerCase()) !== -1
                    })
                }
            }
        }

        в компонентах регистрируем mixin, сначала импортируем и потом в свойстве mixins: [] в массив добавляем тот обьект:
           import ListMixin from './listMixin.js'
           mixins: [ListMixin]

        Важно заметить внутри файла обьекта можно использовать абсолютно весь функционал Vue и если значения из миксинов и компонентов
        повторяются то сначала будет производиться значения из компонента а потом из миксина:
         data() {
            return {
                msg: 'Welcome to Your Vue.js App',
            }
         },
          mixins: [ListMixin]

          глобально создается через метод:
          Vue.mixin({
              beforeCreate(){
                console.log('beforecreate')
              }
          })
}




Работа с формами {
    textarea: если мы хотим чтобы при сохранении модели через v-model в текстовом поле также сохранялись пробелы и табуляции,
    то в стилях пропишем следующее:
    p{
        white-space: pre;
    }
    то есть мы разрешаем через css отображать white-spaces у параграфа


    checkbox: для моделирования чекбоксов делаем следующее:
    создаем масстив куда сохранять будем значения,
     social: []
    создаем input с типом checkbox даем им значение и добавляем v-model на этот массив:
        <label for="">
            <input type="checkbox" value="vk" v-model="social"> Vk
        </label>
        <label for="">
            <input type="checkbox" value="facebook" v-model="social"> Facebook
        </label>
        <label for="">
            <input type="checkbox" value="instagram" v-model="social"> Instagram
        </label>


    radio:
    такая же структура как у checkbox , но переменная уже будет не массивом а просто строкой:
    social: ''


    select:
        <select v-model="defaultSocial">
            <option v-for="item in socialList">{{item}}</option>
        </select>

        и в массиве data:
        socialList: ['instagram', 'vk', 'facebook'],
        defaultSocial: 'facebook'

    number:
    в html в input всегда возвращается строка, но если нам нужно получить именно number значение, для этого мы можем использовать
    модификатор .number:
    <input type="number" v-model.number="age">


    использование v-model на компонентах:
    Пользовательские события также могут использоваться для создания нестандартных элементов
    ввода, которые работают через v-model.
    При использовании на компоненте, v-model вместо этого делает следующее:
    <custom-input
      v-bind:value="searchText"
      v-on:input="searchText = $event"
    ></custom-input>

    Чтобы это действительно работало, элемент <input> внутри компонента должен:

    Привязывать значение атрибута value к входному параметру value
    По событию input генерировать собственное пользовательское событие input с новым значением
    Вот это в действии:

    Vue.component('custom-input', {
      props: ['value'],
      template: `
        <input
          v-bind:value="value"
          v-on:input="$emit('input', $event.target.value)"
        >
      `
    })
    Теперь v-model будет прекрасно работать с этим компонентом:

    <custom-input v-model="searchText"></custom-input>

    в нашем случае:
        создаем компонент onoff и подключим в app.vue:
         <onoff v-model="switched"></onoff>
            <div>
                <h3 v-if="switched">Component is enabled</h3>
                <h3 v-else>Component is disabled</h3>
            </div>

         switched: false
        значение передаваемое в компонент будет получено в props
        props: ['value'],

        далее внутри onoff прописываем:
        <div>
            <button class="on" :class="{'active' : value}" @click="onChange(true)">On</button>
            <button class="off" :class="{'active' : !value}" @click="onChange(false)">Off</button>
        </div>

        где также есть методы:
        methods: {
            onChange(newValue) {
                this.$emit('input', newValue);
            }
        }
}





Валидация:
{
    в Vue нету встроенной валидации, но можно подключить пакет vuelidate, после установки через команду
    npm install vuelidate --save
    мы подключаем ее в main.js и используем в vue:
    import Vuelidate from 'vuelidate'
    Vue.use(Vuelidate);

    чтобы использовать валидацию input мы должны подключить валидаторы в обьекте Vue:
    import { required, email} from 'vuelidate/lib/validators'

    и уже конкретно для валидации определенной переменной в свойстве validations мы прописываем:
     validations: {
        email : {
            required,
            email
        }
     }

     а input подключаем обработчик события на blur:
      <input type="email" id="email" class="form-control" @blur="$v.email.$touch()" v-model="email">


    визуализировать ошибки очень просто:
    <input type="email"
       id="email"
       class="form-control"
       :class="{'is-invalid' : $v.email.$error}"
       @blur="$v.email.$touch()"
       v-model="email">
     <div v-if="!$v.email.required" class="invalid-feedback">
         Email field is required!
     </div>
     <div v-if="!$v.email.email" class="invalid-feedback">
         This field should be email!
     </div>

     Используя простую bootstrap визуализацию мы можем отображать ошибки валидации:
     1 - для покрашивания границ в красный мы биндим class на $v.email.$error, то есть если есть хоть какая то ошибка,
     то будет подключен is-invalid класс

     2 - подключаем в DOM div с классом invalid-feedback через условия если не соответствуют определенным параметрам валидации:
      v-if="!$v.email.email"




    валидация пароля:
    обычная валидация на required, но также добавим валидацию по потверждению пароля:
    для этого создадим новую модель, и валидацию для нее:
    confirm_password: ''
    confirm_password: {
        required,
        sameAs: sameAs((vue)=>{
            return vue.password
        })
    }

    как видно мы используем ключ значение обьект, где передаем обьект vue и у него берем password, это делается в случае
    многоуровневых переменных:
    form: {
        password: ''
    }

    и такая же html форма:
    <label for="confirm_password">Confirm Password</label>
    <input type="password"
           id="confirm_password"
           class="form-control"
           :class="{'is-invalid' : $v.confirm_password.$error}"
           @blur="$v.confirm_password.$touch()"
           v-model="confirm_password">
    <div v-if="!$v.confirm_password.sameAs" class="invalid-feedback">
        Password should match!
    </div>
    <div v-if="!$v.confirm_password.required" class="invalid-feedback">
        Password field is required!
    </div>



    собственный валидатор:
    для создания своего валидатора достаточно в validations создать новый ключ и присвоить функцию которая будет возвращать либо true либо false:
    uniqueEmail: function(newEmail) {
            if(newEmail === '') return true;
           return new Promise((resolve,reject)=>{
                setTimeout(()=>{
                    let value = newEmail !== 'test@mail.ru'
                    resolve(value)
                }, 1800)
           })

            // return newEmail !== 'test@mail.ru'
    }
    true значит проходит валидацию, false если нет
    <div v-if="!$v.email.uniqueEmail" class="invalid-feedback">
        This email already exists!
    </div>


    для обработки формы создадим кнопку:
    <button type="submit" class="btn btn-success mt-3" :disabled="$v.$invalid">Submit</button>

    и у формы добавим event listener @submit:
    <form class="pt-4" @submit.prevent="onSubmit">
}





Vue - router {
    устанавливаем npm install vue-router --save
    далее в main.js добавляем следующее:

    import VueRouter from 'vue-router'
    Vue.use(VueRouter);


    lesson 2 {
        создаем n страниц:
        для этого создаем папку pages в src где будут храниться компоненты которые и есть по сути страницы

        далее чтобы их зарегистрировать мы создадим в src файл под названием routes.js где будет экспортироваться по дефолту
        обьект VueRouter который в виде массива будет хранить эти компоненты с назначенными на них путями:

            import VueRouter from 'vue-router'
            import Home from  './pages/Home.vue'
            import Cars from  './pages/Cars.vue'

            export default new VueRouter ({
                routes: [
                    {
                        path: '', //localhost:8080
                        component: Home
                    },
                    {
                        path: '/cars',
                        component: Cars
                    }
                ],
                mode: 'history'
            });
        тут мы видим что импортируются компоненты, где в виде массива мы сохраняем их как обьекты, также в свойстве mode
        мы добавили history для того чтобы убрать хештег в дефолтном роуте

        и чтобы все работало мы экспортируем этот обьект в main.js:
            import router from './routes'

            new Vue({
              el: '#app',
              render: h => h(App),
              router    // вот он
            });

        и запускаем в App.vue в виде тега <router-view>. Vue.js сам поймет что нужно делать с этим тегом

        теперь у нас при вводе в url страницы либо / либо /cars мы динамически будем менять страницу
    }


    lesson 3 {
        для того чтобы сделать смену страницы динамически нужно вместо тега <a> создать тег <router-link> и в его атрибуте
        to написать путь:
            nav class="navbar navbar-expand-lg navbar-light bg-light">
              <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav mr-auto">
                  <li class="nav-item">
                    <router-link class="nav-link" to="/">Home</router-link>
                  </li>
                  <li class="nav-item">
                    <router-link class="nav-link" to="/cars">Cars</router-link>
                  </li>
                </ul>
              </div>
            </nav>
        здесь используется bootstrap 4

        теперь все работет динамически
    }

    lesson 4 {
        чтобы стилизовать активные страницы необходимо создать router-link не просто на тег <a> а на весь блок:
        то есть заменяем:
            <li class="nav-item">
                <router-link class="nav-link" to="/cars">Cars</router-link>
             </li>
        на :
             <router-link tag="li" class="nav-item" to="/cars" active-class="active">
                <a class="nav-link">Cars</a>
              </router-link>

        тут мы видим что мы присвоили router-link тег - li, далее добавляем class, и в специальном аттрибуте
        active-class добавляем необходимый класс, также чтобы при переходе на каждый пункт active класс был уникальным
        необходимов добавить аттрибут exact для самого первого пункта:
            <router-link tag="li" class="nav-item" exact to="/" active-class="active">
                <a class="nav-link">Home</a>
            </router-link>
    }

    lesson 5 {
        динамические роуты с параметрами
        допустим мы хотим выводить в /cars список всех машин, и это будет динамически:
        для этого создадим в Cars.vue список:
            <ul>
                <router-link tag="li" class="nav-item"
                v-for="car in 5"
                :to="'/car/'+car"
                :key="car">
                    <a class="nav-link">Car {{car}}</a>
                </router-link>
            </ul>
        здесь мы создаем 5 ссылок на /car который будет обрабатываться vue-routerом

        далее создадим страницу для каждой отдельной машины, и добавим компонент в routes.js:

        Car.vue:
            <template>
                <div>
                    <h1>Car id {{id}}</h1>
                </div>
            </template>

            <script>
                export default {
                    data() {
                        return {
                            // id: this.$router.currentRoute.params['id']  либо так либо как снизу
                            id: this.$route.params['id']
                        }
                    },
                    watch: {
                        $route(toR, fromR) {
                            this.id = toR.params['id']
                        }
                    }
                }
            </script>
        Тут мы берем значение передаваемое в Url строку через методы:
        this.$route.params['id']
        а также для того чтобы id сменялось динамически мы в стату watch() добавили просмотр изменения id ,
        без него цифра не будет меняться

        routes.js:
            import Car from './pages/Car.vue'
            ...
             {
                path: '/car/:id', // id можем называть как угодно
                component: Car
             }
            ...

        и в App.vue добавим дополнительно ссылки на 3 и 4 машины:
            <router-link tag="li" class="nav-item" to="/car/3" active-class="active">
            <a class="nav-link">Car 3 </a>
          </router-link>

          <router-link tag="li" class="nav-item" to="/car/4" active-class="active">
            <a class="nav-link">Car 4</a>
          </router-link>
    }

    lesson 6 {
        программная навигация:
        создадим ссылку в Car которая будет возвращать к списку всех машин, для этого создадим в Car.vue кнопку:
             <button class="btn btn-sm btn-info" @click="goBackToCars">Back</button>
        ей присвоим обработчик события goBackToCars():
             goBackToCars(){
                this.$router.push('/cars')
             }
        данный обработчик вызывает у $router метод push() с адресом страницы куда надо перейти
    }


    lesson 7 {
        внутренние роуты
        создадим внутренний роут CarFull, т.к. он дочерний у Car то мы должны его зарегистрировать в свойстве children
        в routes.js:
            {
                path: '/car/:id', // id можем называть как угодно
                component: Car,
                children: [
                    {
                        path: 'full', //localhost:8080/car/10/full
                        component: CarFull,
                        name:'CarFull'
                    }
                ]
            },
        тут нужно заметить что есть еще свойство name, необходимое для перехода по to в router-link
        далее для того чтобы данный компонент был виден мы должны в Car.vue добавить тег <router-view> т.к
        это его дочерний view:
            <router-link class="btn btn-sm btn-info mt-2"
                         tag="button"
                        :to="{name: 'CarFull', params: {id: id}}"
            >Full info</router-link>
            <hr>
            <router-view></router-view>

         также мы тут добавили кнопку вызывающюю данный компонент, и у нее в атрибуте to мы забиндили такую конструкцию:
            :to="{name: 'CarFull', params: {id: id}}"
         она нам говорит чтобы путь был туда у которого в компоненте есть данное имя с параметрами, в нашем случае
         параметр это id у Car пути, и его ребенке carfull:
         path: '/car/:id' +  path: 'full', //localhost:8080/car/10/full

    }

    lesson 8 {
        передача параметров:
        query параметры это параметры которые передаются методом GET в url

        допустим мы хотим передавать имя и год машины в компонент CarFull, для этого нам необходимо в аттрибут to в
        компоненте Car добавить следующее:
            :to="{name: 'CarFull', params: {id: id}, query: {name: 'Mazda', year: 2000}}"
        тоесть в query отправляем обьект с определенными свойствами

        далее обрабатываем этот query в CarFull:
            <template>
            <div>
                <h4>Car name: {{ this.$route.query['name']}}</h4>
                <h5>Car year: {{ year}}</h5>
            </div>
            </template>

            <script>
            export default {
                computed: {
                    year(){
                        return  this.$route.query.year;
                    }
                }
            }
            </script>
        таким образом мы можем получить данные либо через структуру this.$route.query.name
        либо через computed метод
    }


    lesson 9 {
        хэш и скролл:
        хэш передается для того чтобы мы могли перейти в шаблоне к определенному id
        для примера в CarFullсоздадим блоки и h6 с id:
            <div class="scroll"></div>
            <h6 id="scroll">Hello from the bottom</h6>
            <div class="scroll"></div>

            <style>
            .scroll {
                width: 100px;
                height: 1000px;
                background: #ccc;
            }
            </style>

        далее в Car пути добавим такое свойство как hash, оно как раз и будет отправлять нас по id
        данный параметр должен получать строку начинающюся с #:
            <router-link class="btn btn-sm btn-info mt-2"
                         tag="button"
                        :to="{name: 'CarFull', params: {id: id}, query: {name: 'Mazda', year: 2000}, hash: '#scroll'}"
            >Full info</router-link>

        чтобы все работало правильно мы должны в routes.js создать новый метод scrollBehavior у обьекта VueRouter:
             scrollBehavior (to, from, savedPosition){
                if(savedPosition){
                    return savedPosition;
                }
                if(to.hash){
                    return {selector: to.hash};
                }
                return {
                    x:0,
                    y:0
                };
            }
         тут мы видим что данная функция принимает себе to, from, savedPosition, именно данная функция будет переносить
         нас тут куда прописано в коде:
         для этого идут 3 проверки, первая нужна для того чтобы возвращать именно на ту позицию с которой начали,
         вторая это to.hash то есть если у url есть hash то перенести именно к блоку с данным id и третья по дефолту
    }


    lesson 10 {
        Редиректы
        для того чтобы редиректить нужно в свойствах обьектов VueRouter создать свойство redirect:
            {
                path: '/none',
                redirect: {
                    name: 'Cars'
                }
            },
        в данном примере при попытке перейти на роут none произойдет редирект на Cars

        если мы хотим создать страницу 404: то для этого создадим компонент Eror и добавим его в routes.js:
            <template>
                <h1 style="color: red;">404 Error</h1>
            </template>

        и зарегистрируем:
            {
                path: '*',
                component: ErrorCmp
            }
        тут мы видим что при любых других роутах будет вызван этот компонент
    }


    lesson 11 {
        защита роутов

        если мы хотим добавить какие то проверки перед переходом на какие то страницы, то для этого нам нужно
        их защищать
        первый способ это добавления метода beforeEnter() к обьектам VueRouter:
            beforeEnter(to, from, next){
                if(smth...){
                    next(true);
                }
                else{
                    next(false);
                }
            }
        данный метод принимает to, from, next метода и проверяет определенную логику и далее либо разрешает переход либо нет

        второй способ это добавления методов к компонентам:
        метод beforeRouteEnter(to, from, next) и beforeRouteLeave(to, from, next) выполняют такую же логику но пишутся уже в
        компонентах
    }


    lesson 12 {
        Eager loading оптимизация
        для оптимизации проекта желательно все страницы загружать по требованию а не сразу, если мы используме import
        структуру то все компоненты будут подгружаться сразу, для использования lazy loading необходимо добавлять компоненты вот так:
        в routes.js:
            const Cars = resolve=>{
                require.ensure(['./pages/Cars.vue'], ()=>{
                    resolve(
                        require('./pages/Cars.vue')
                    )
                })
            };
        данную схему webpack сам понимает и будет соответственно определенно подгружать, так мы подключим Cars.vue по требованию
    }
}



Vue -resource:{
    lesson 1 {
        pagekit/vue-resource устанавливаем
        плагин для того чтобы делать асинхронные запросыы
        npm install vue-resource --save

        и сразу добавим его в main.js:
        import VueResource from 'vue-resource'
        Vue.use(VueResource);
        
        далее устанавливаем глобально JSON-server:
        npm install -g json-server

        и обязательно локально:
        npm install --save-dev json-server

        добавим в package.json новую конфигурацию:
        "scripts": {
            "server": "json-server --watch db.json"
        },
        таким образом мы можем запустить наш сервер открыв в консоли npm run server

        и обязательно создадим в корневой папке файл db.json:
        {
            "cars": [ ]
        }

        запускаем 2 терминала: в одном пропишем npm run dev, во втором npm run server
    }
}