для того чтобы подключить Vue можно использовать CDN добавляем его в скрипты:
<script src="https://unpkg.com/vue@2.5.16/dist/vue.js"></script>
с сайта unpkg всегда самые новейшие обновления

Чтобы инициализоровать Vue достаточно создать переменную и присвоить ей обьект Vue()
в него передаем несколько обязательных параметров:
1 - element - элемент который мы привяжем с Vue
2 - обьект data внутри которого можем добавялть любые данные:
    var app = new Vue({
        el:'#app',
        data: {
            message: 'Hello Vue!'
        }
    });
использовать данные vue можно через {{}} как в blade:
    <div id="app">
        <h1>{{message}}</h1>
    </div>





урок 2  Directive{
Директивы — это специальные атрибуты с префиксом v-.
В качестве значения такие атрибуты принимают одно выражение JavaScript (за исключением v-for, о которой ниже).
 Директива реактивно применяет к DOM изменения при обновлении значения этого выражения.

 v-text="variable" - данная директивы будет отображать значение переменной
 v-html = "var" - директива по функции похожа на .innerHtml у js
 разница между двумя этими директивами в том что v-text - не отображает html теги

v-show="var" - данная директива будет показаывать элемент, если переменная равна true, если false то скроет данный элемент, по факту он меняет параметр CSS : display:none, inline  и т.д.:
 true: <h1>You have viewed this page</h1>
 false:<h1 style="display: none;">You have viewed this page</h1>
v-if="var" - похожа на v-show, но разница в том что данная директива удаляет из DOM элемент:
 true: <h1>You have viewed this page</h1>
 false: <!---->
в них можно прописывать более тяжелую логику чем просто true, false:
    v-if="viewed == viewed2"
v-else  соответственно покажет при не сработанном v-if

v-pre - директива которая говорит Vue.js не рендерить данны элемент:
 <h1 v-pre>{{message}}</h1> - то есть с директивой v-pre на экран выведится в таком виде: {{message}}

 v-once - рендерить только один раз, то есть
  <h1 v-once>{{message}}</h1>  - будет сгенерировано один раз, а если мы будем изменять message на ходу, то все равно в данном элементе изменения не будут отображены

v-cloak - Эта директива останется на элементе до тех пор, пока связанный с ним экземпляр Vue не закончит компиляцию.
В сочетании с CSS-правилом [v-cloak] { display: none } этой директивой можно скрывать нескомпилированные шаблоны до тех пор, пока экземпляр Vue не будет готов.

}


урок 3 Директива v-bind {
Сокращение: :
Принимает: any (если указан параметр) | Object (если параметр не указан)
Параметр: attrOrProp (опционально)
Модификаторы:
.prop — используется для связывания в качестве DOM-свойства, а не атрибута (в чём разница?). Если тег является компонентом, то .prop будет устанавливать свойство на $el компонента.
.camel — (2.1.0+) преобразует имена атрибутов из kebab-case в camelCase.
.sync — (2.3.0+) синтаксический сахар, который будет преобразован в обработчик v-on для обновления связанного значения.
Использование:
Динамически связывает атрибуты тега или входной параметр компонента с выражением.
При использовании с атрибутами class и style поддерживает массивы и объекты в качестве значений. Подробнее это описано в соответствующем руководстве по ссылке ниже.
Для правильного связывания входного параметра компонента, тот должен быть корректно определён в дочернем компоненте.
Если аргумент не указан, связанное значение может быть содержащим пары имя-значение. Обратите внимание, что в этом случае атрибуты class и style не поддерживают массивы и объекты.

<img :src="url" :alt="title"> - таким образом мы биндим аттрибут src к url переменной
}



урок 4 v-for {
Принимает: Array | Object | number | string

Использование:

Многократно рендерит элемент или блок шаблона, основываясь на переданных данных. Значение директивы должно следовать синтаксису alias in expression — в alias будет элемент текущей итерации:

<div v-for="item in items">
  {{ item.text }}
</div>
Кроме того, вы можете указать название для индекса (или ключа, если вы работаете с объектом):

<div v-for="(item, index) in items"></div>
<div v-for="(val, key) in object"></div>
<div v-for="(val, key, index) in object"></div>
По умолчанию v-for будет пытаться обновить элементы “на месте”, не перемещая их. Если вам
}



урок 5 2-way binding{
v-model ="variable"
Принимает: разное, в зависимости от типа форм или выходных данных компонентов

Используется только с:

<input>
<select>
<textarea>
компонентами
Модификаторы:

.lazy — подписаться на события change, а не input
.number — приводить введённую строку к числу
.trim — удалять пробелы в начале и в конце введённой строки
Использование:

Двусторонним образом связывает элемент ввода данных или компонент с переменной. Директива подробно описана в руководстве по ссылке ниже.

<input type="text" v-model="message">
}



урок 6 events{
    v-on    Сокращение: @

    Принимает: Function | Inline-выражение | Object

    Параметр: event

    Модификаторы:

    .stop — вызовет event.stopPropagation().
    .prevent — вызовет event.preventDefault().
    .capture — добавит подписку в режиме capture.
    .self — вызовет обработчик только если событие возникло непосредственно на этом элементе.
    .{keyCode | keyAlias} — вызывает обработчик только при нажатии определённой клавиши.
    .native — подписаться на нативное событие на корневом элементе компонента.
    .once — вызовет обработчик не больше одного раза.
    .left - (2.2.0) вызов обработчика только по событию нажатия левой кнопки мыши.
    .right - (2.2.0) вызов обработчика только по событию нажатия правой кнопки мыши.
    .middle - (2.2.0) вызов обработчика только по событию нажатия средней кнопки мыши.
    .passive - (2.3.0+) вызов обработчика события DOM с опцией { passive: true }.
    Использование:

    Прикрепляет к элементу подписчик события. Тип события указывается в параметре. Выражение может быть именем метода, inline-выражением или вовсе отсутствовать, если указан один или несколько модификаторов.

    У обычного элемента можно подписаться только на нативные события DOM. У элемента компонента можно подписаться на пользовательские события, вызываемые этим дочерним компонентом.

    При работе с нативными событиями DOM, метод получает нативное событие единственным аргументом. В inline-выражениях, можно получить к нему доступ с помощью $event: v-on:click="handle('ok', $event)".

    Начиная с версии 2.4.0+, v-on также поддерживает привязку к объекту пар событие/обработчик без аргумента. Обратите внимание, что при использовании синтаксиса объекта не поддерживаются никакие модификаторы.

    все события во vue регистрирутся через директиву v-on:event="method" (click, keydown)
    все методы регистрируются в обьекте vue в свойстве methods:

    var app = new Vue({
        el:'#app',
        data: {
            message: 'Hello Vue!'
        },
        methods: {
             countUp: function () {
                this.count += 1
             },
        }
    });
}


урок 8 computed properties{
Выражения, встраиваемые в шаблоны, удобны, но предназначены они только для простых операций.
При усложнении логики, они быстро становятся трудноподдерживаемыми. Например:

<div id="example">
  {{ message.split('').reverse().join('') }}
</div>
Этот шаблон уже не выглядит просто и декларативно.
С первого взгляда и не скажешь, что он всего лишь отображает message задом наперёд.
Ситуация станет ещё хуже, если эту логику в шаблоне потребуется использовать в нескольких местах.

На помощь приходят вычисляемые свойства.

Простой пример
<div id="example">
  <p>Изначальное сообщение: "{{ message }}"</p>
  <p>Сообщение задом наперёд: "{{ reversedMessage }}"</p>
</div>
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Привет'
  },
  computed: {
    // геттер вычисляемого значения
    reversedMessage: function () {
      // `this` указывает на экземпляр vm
      return this.message.split('').reverse().join('')
    }
  }
})
Результат:
Изначальное сообщение: "Привет"
Сообщение наоборот: "тевирП"

Здесь мы определили вычисляемое свойство reversedMessage. Написанная нами функция будет использоваться как геттер свойства vm.reversedMessage:

console.log(vm.reversedMessage) // => 'тевирП'
vm.message = 'Пока'
console.log(vm.reversedMessage) // => 'акоП'
Вы можете открыть консоль и поиграть с примером сами. Значение vm.reversedMessage всегда зависит от значения vm.message.

В шаблонах вы можете привязываться к вычисляемым свойствам ровно таким же образом, как и к обычным.
 Vue знает, что vm.reversedMessage зависит от vm.message, так что при обновлении vm.message обновятся и все элементы, зависящие от vm.reversedMessage.
 И самое главное, что эту зависимость мы указали декларативно: геттер вычисляемого свойства не имеет побочных эффектов, что упрощает как понимание кода, так и тестирование.
}


урок 8, computed setters and getters{

разница между методами и computed properties в том что vuejs кеширует computed properties так что в при обьявлении нового обьекта
и использовании того же computed property vue просто возьмет с кеша сохраненные значения.


computed properties созданы для того чтобы их подключать к getters and setters

по умолчанию мы работаем с геттером
 fullname: function() {
                return this.first + " " + this.last
 }

чтобы создать setter нужно распределить computed properties на get и set, также есть input для fullname:
<label>Full Name:</label>
<input type="text" class="form-control" v-model="fullname" />

 fullname: {
                //getter getting fullname as combination of first and last name
                get: function () {
                    return this.first + " " + this.last;
                },
                //setter setting first and lastname be changing computed properties input
                set: function (fullname) {
                    var name = fullname.split(' ');
                    this.firstName=name[0];
                    this.lastName=name[name.length-1];
                }
            }

По умолчанию вычисляемые свойства работают только на чтение, но в случае необходимости вы можете также указать и сеттер:

// ...
computed: {
  fullName: {
    // геттер:
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // сеттер:
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
Теперь запись vm.fullName = 'Иван Иванов' вызовет сеттер, и vm.firstName и vm.lastName будут соответствующим образом обновлены.
}


урок 10 AJAX {
watch
Тип: { [key: string]: string | Function | Object | Array }

Подробности:

Объект, ключи которого — выражения для наблюдения, а значения — коллбэки, вызываемые при их изменении. Значения также могут быть строками с именами методов, или объектами, содержащими дополнительные опции. Экземпляр Vue вызовет $watch() соответствующий каждому ключу объекта при своём создании.

Пример:

var vm = new Vue({
  data: {
    a: 1,
    b: 2,
    c: 3,
    d: 4,
    e: {
      f: {
        g: 5
      }
    }
  },
  watch: {
    a: function (val, oldVal) {
      console.log('новое значение: %s, старое значение: %s', val, oldVal)
    },
    // строка с именем метода:
    b: 'someMethod',
    // глубокий (рекурсивный) наблюдатель:
    c: {
      handler: function (val, oldVal) { /* ... */ },
      deep: true
    },
    // коллбэк будет вызван сразу же после начала наблюдения
    d: {
      handler: function (val, oldVal) { /* ... */ },
      immediate: true
    },
    e: [
      function handle1 (val, oldVal) { /* ... */ },
      function handle2 (val, oldVal) { /* ... */ }
    ],
    // отслеживание значения `vm.e.f`: {g: 5}
    'e.f': function (val, oldVal) { /* ... */ }
  }
})
vm.a = 2 // => новое значение: 2, старое значение: 1
Обратите внимание, что вам не стоит использовать стрелочные функции при определении наблюдателей
 (напр. searchQuery: newValue => this.updateAutocomplete(newValue)).
 Поскольку стрелочные функции связываются с родительским контекстом,
 this не будет указывать на экземпляр Vue, и this.updateAutocomplete окажется неопределённым.



нужно отправлять после написания 5 символов, для этого используется свойство watch у vuejs:
в нем мы пропишем что пока не набраны 5 символов, startingCity будет пустой строкой, далее идет проверка и вызов метода
который будет отправлять api запрос:
 startingZip: function () {
                this.startingCity = '';
                if(this.startingZip.length==5){
                    //call API
                    this.lookupStartingZip();
                }
            }

 далее  метод lookupStartingZip () должен вызвать методы axios которые непосрелственно будут отправлять запрос API,
 после получения данных мы приравниваем их к нашему startingCity:
 lookupStartingZip: _.debounce(function () {
                 var vm =this;//vue model
                 vm.startingCity = "Searching...";
                 //API request
                 axios.get('http://ziptasticapi.com/' + vm.startingZip)
                     .then(function (response) {
                     vm.startingCity = response.data.city + ', ' + response.data.state;
                 })
                     .catch(function (error) {
                         vm.startingCity="Invalid Zipcode";
                     });
             }, 500),

 тут также используется метод _debounce(function, delay) - суть которого в том что он позволяет вызвать определенный метод
 через определенное количество миллисекунд, это нужно для того чтобы не произошли не предвиденные изменения, плюс для лучшего UI
 мы сначала пропишем в startingCity значение Searching..., чтобы пока идет запрос пользователь видел что что-то будет изменяться
}