 для того чтобы подключить Vue можно использовать CDN добавляем его в скрипты:
<script src="https://unpkg.com/vue@2.5.16/dist/vue.js"></script>
с сайта unpkg всегда самые новейшие обновления

Чтобы инициализоровать Vue достаточно создать переменную и присвоить ей обьект Vue()
в него передаем несколько обязательных параметров:
1 - element - элемент который мы привяжем с Vue
2 - обьект data внутри которого можем добавялть любые данные:
    var app = new Vue({
        el:'#app',
        data: {
            message: 'Hello Vue!'
        }
    });
использовать данные vue можно через {{}} как в blade:
    <div id="app">
        <h1>{{message}}</h1>
    </div>





урок 2  Directive{
Директивы — это специальные атрибуты с префиксом v-.
В качестве значения такие атрибуты принимают одно выражение JavaScript (за исключением v-for, о которой ниже).
 Директива реактивно применяет к DOM изменения при обновлении значения этого выражения.

 v-text="variable" - данная директивы будет отображать значение переменной
 v-html = "var" - директива по функции похожа на .innerHtml у js
 разница между двумя этими директивами в том что v-text - не отображает html теги

v-show="var" - данная директива будет показаывать элемент, если переменная равна true, если false то скроет данный элемент, по факту он меняет параметр CSS : display:none, inline  и т.д.:
 true: <h1>You have viewed this page</h1>
 false:<h1 style="display: none;">You have viewed this page</h1>
v-if="var" - похожа на v-show, но разница в том что данная директива удаляет из DOM элемент:
 true: <h1>You have viewed this page</h1>
 false: <!---->
в них можно прописывать более тяжелую логику чем просто true, false:
    v-if="viewed == viewed2"
v-else  соответственно покажет при не сработанном v-if

v-pre - директива которая говорит Vue.js не рендерить данны элемент:
 <h1 v-pre>{{message}}</h1> - то есть с директивой v-pre на экран выведится в таком виде: {{message}}

 v-once - рендерить только один раз, то есть
  <h1 v-once>{{message}}</h1>  - будет сгенерировано один раз, а если мы будем изменять message на ходу, то все равно в данном элементе изменения не будут отображены

v-cloak - Эта директива останется на элементе до тех пор, пока связанный с ним экземпляр Vue не закончит компиляцию.
В сочетании с CSS-правилом [v-cloak] { display: none } этой директивой можно скрывать нескомпилированные шаблоны до тех пор, пока экземпляр Vue не будет готов.

}


урок 3 Директива v-bind {
Сокращение: :
Принимает: any (если указан параметр) | Object (если параметр не указан)
Параметр: attrOrProp (опционально)
Модификаторы:
.prop — используется для связывания в качестве DOM-свойства, а не атрибута (в чём разница?). Если тег является компонентом, то .prop будет устанавливать свойство на $el компонента.
.camel — (2.1.0+) преобразует имена атрибутов из kebab-case в camelCase.
.sync — (2.3.0+) синтаксический сахар, который будет преобразован в обработчик v-on для обновления связанного значения.
Использование:
Динамически связывает атрибуты тега или входной параметр компонента с выражением.
При использовании с атрибутами class и style поддерживает массивы и объекты в качестве значений. Подробнее это описано в соответствующем руководстве по ссылке ниже.
Для правильного связывания входного параметра компонента, тот должен быть корректно определён в дочернем компоненте.
Если аргумент не указан, связанное значение может быть содержащим пары имя-значение. Обратите внимание, что в этом случае атрибуты class и style не поддерживают массивы и объекты.

<img :src="url" :alt="title"> - таким образом мы биндим аттрибут src к url переменной
}



урок 4 v-for {
Принимает: Array | Object | number | string

Использование:

Многократно рендерит элемент или блок шаблона, основываясь на переданных данных. Значение директивы должно следовать синтаксису alias in expression — в alias будет элемент текущей итерации:

<div v-for="item in items">
  {{ item.text }}
</div>
Кроме того, вы можете указать название для индекса (или ключа, если вы работаете с объектом):

<div v-for="(item, index) in items"></div>
<div v-for="(val, key) in object"></div>
<div v-for="(val, key, index) in object"></div>
По умолчанию v-for будет пытаться обновить элементы “на месте”, не перемещая их. Если вам
}



урок 5 2-way binding{
v-model ="variable"
Принимает: разное, в зависимости от типа форм или выходных данных компонентов

Используется только с:

<input>
<select>
<textarea>
компонентами
Модификаторы:

.lazy — подписаться на события change, а не input
.number — приводить введённую строку к числу
.trim — удалять пробелы в начале и в конце введённой строки
Использование:

Двусторонним образом связывает элемент ввода данных или компонент с переменной. Директива подробно описана в руководстве по ссылке ниже.

<input type="text" v-model="message">
}



урок 6 events{
    v-on    Сокращение: @

    Принимает: Function | Inline-выражение | Object

    Параметр: event

    Модификаторы:

    .stop — вызовет event.stopPropagation().
    .prevent — вызовет event.preventDefault().
    .capture — добавит подписку в режиме capture.
    .self — вызовет обработчик только если событие возникло непосредственно на этом элементе.
    .{keyCode | keyAlias} — вызывает обработчик только при нажатии определённой клавиши.
    .native — подписаться на нативное событие на корневом элементе компонента.
    .once — вызовет обработчик не больше одного раза.
    .left - (2.2.0) вызов обработчика только по событию нажатия левой кнопки мыши.
    .right - (2.2.0) вызов обработчика только по событию нажатия правой кнопки мыши.
    .middle - (2.2.0) вызов обработчика только по событию нажатия средней кнопки мыши.
    .passive - (2.3.0+) вызов обработчика события DOM с опцией { passive: true }.
    Использование:

    Прикрепляет к элементу подписчик события. Тип события указывается в параметре. Выражение может быть именем метода, inline-выражением или вовсе отсутствовать, если указан один или несколько модификаторов.

    У обычного элемента можно подписаться только на нативные события DOM. У элемента компонента можно подписаться на пользовательские события, вызываемые этим дочерним компонентом.

    При работе с нативными событиями DOM, метод получает нативное событие единственным аргументом. В inline-выражениях, можно получить к нему доступ с помощью $event: v-on:click="handle('ok', $event)".

    Начиная с версии 2.4.0+, v-on также поддерживает привязку к объекту пар событие/обработчик без аргумента. Обратите внимание, что при использовании синтаксиса объекта не поддерживаются никакие модификаторы.

    все события во vue регистрирутся через директиву v-on:event="method" (click, keydown)
    все методы регистрируются в обьекте vue в свойстве methods:

    var app = new Vue({
        el:'#app',
        data: {
            message: 'Hello Vue!'
        },
        methods: {
             countUp: function () {
                this.count += 1
             },
        }
    });
}


урок 8 computed properties{
Выражения, встраиваемые в шаблоны, удобны, но предназначены они только для простых операций.
При усложнении логики, они быстро становятся трудноподдерживаемыми. Например:

<div id="example">
  {{ message.split('').reverse().join('') }}
</div>
Этот шаблон уже не выглядит просто и декларативно.
С первого взгляда и не скажешь, что он всего лишь отображает message задом наперёд.
Ситуация станет ещё хуже, если эту логику в шаблоне потребуется использовать в нескольких местах.

На помощь приходят вычисляемые свойства.

Простой пример
<div id="example">
  <p>Изначальное сообщение: "{{ message }}"</p>
  <p>Сообщение задом наперёд: "{{ reversedMessage }}"</p>
</div>
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Привет'
  },
  computed: {
    // геттер вычисляемого значения
    reversedMessage: function () {
      // `this` указывает на экземпляр vm
      return this.message.split('').reverse().join('')
    }
  }
})
Результат:
Изначальное сообщение: "Привет"
Сообщение наоборот: "тевирП"

Здесь мы определили вычисляемое свойство reversedMessage. Написанная нами функция будет использоваться как геттер свойства vm.reversedMessage:

console.log(vm.reversedMessage) // => 'тевирП'
vm.message = 'Пока'
console.log(vm.reversedMessage) // => 'акоП'
Вы можете открыть консоль и поиграть с примером сами. Значение vm.reversedMessage всегда зависит от значения vm.message.

В шаблонах вы можете привязываться к вычисляемым свойствам ровно таким же образом, как и к обычным.
 Vue знает, что vm.reversedMessage зависит от vm.message, так что при обновлении vm.message обновятся и все элементы, зависящие от vm.reversedMessage.
 И самое главное, что эту зависимость мы указали декларативно: геттер вычисляемого свойства не имеет побочных эффектов, что упрощает как понимание кода, так и тестирование.
}


урок 8, computed setters and getters{

разница между методами и computed properties в том что vuejs кеширует computed properties так что в при обьявлении нового обьекта
и использовании того же computed property vue просто возьмет с кеша сохраненные значения.


computed properties созданы для того чтобы их подключать к getters and setters

по умолчанию мы работаем с геттером
 fullname: function() {
                return this.first + " " + this.last
 }

чтобы создать setter нужно распределить computed properties на get и set, также есть input для fullname:
<label>Full Name:</label>
<input type="text" class="form-control" v-model="fullname" />

 fullname: {
                //getter getting fullname as combination of first and last name
                get: function () {
                    return this.first + " " + this.last;
                },
                //setter setting first and lastname be changing computed properties input
                set: function (fullname) {
                    var name = fullname.split(' ');
                    this.firstName=name[0];
                    this.lastName=name[name.length-1];
                }
            }

По умолчанию вычисляемые свойства работают только на чтение, но в случае необходимости вы можете также указать и сеттер:

// ...
computed: {
  fullName: {
    // геттер:
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // сеттер:
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
Теперь запись vm.fullName = 'Иван Иванов' вызовет сеттер, и vm.firstName и vm.lastName будут соответствующим образом обновлены.
}


урок 10 AJAX {
watch
Тип: { [key: string]: string | Function | Object | Array }

Подробности:

Объект, ключи которого — выражения для наблюдения, а значения — коллбэки, вызываемые при их изменении. Значения также могут быть строками с именами методов, или объектами, содержащими дополнительные опции. Экземпляр Vue вызовет $watch() соответствующий каждому ключу объекта при своём создании.

Пример:

var vm = new Vue({
  data: {
    a: 1,
    b: 2,
    c: 3,
    d: 4,
    e: {
      f: {
        g: 5
      }
    }
  },
  watch: {
    a: function (val, oldVal) {
      console.log('новое значение: %s, старое значение: %s', val, oldVal)
    },
    // строка с именем метода:
    b: 'someMethod',
    // глубокий (рекурсивный) наблюдатель:
    c: {
      handler: function (val, oldVal) { /* ... */ },
      deep: true
    },
    // коллбэк будет вызван сразу же после начала наблюдения
    d: {
      handler: function (val, oldVal) { /* ... */ },
      immediate: true
    },
    e: [
      function handle1 (val, oldVal) { /* ... */ },
      function handle2 (val, oldVal) { /* ... */ }
    ],
    // отслеживание значения `vm.e.f`: {g: 5}
    'e.f': function (val, oldVal) { /* ... */ }
  }
})
vm.a = 2 // => новое значение: 2, старое значение: 1
Обратите внимание, что вам не стоит использовать стрелочные функции при определении наблюдателей
 (напр. searchQuery: newValue => this.updateAutocomplete(newValue)).
 Поскольку стрелочные функции связываются с родительским контекстом,
 this не будет указывать на экземпляр Vue, и this.updateAutocomplete окажется неопределённым.



нужно отправлять после написания 5 символов, для этого используется свойство watch у vuejs:
в нем мы пропишем что пока не набраны 5 символов, startingCity будет пустой строкой, далее идет проверка и вызов метода
который будет отправлять api запрос:
 startingZip: function () {
                this.startingCity = '';
                if(this.startingZip.length==5){
                    //call API
                    this.lookupStartingZip();
                }
            }

 далее  метод lookupStartingZip () должен вызвать методы axios которые непосрелственно будут отправлять запрос API,
 после получения данных мы приравниваем их к нашему startingCity:
 lookupStartingZip: _.debounce(function () {
                 var vm =this;//vue model
                 vm.startingCity = "Searching...";
                 //API request
                 axios.get('http://ziptasticapi.com/' + vm.startingZip)
                     .then(function (response) {
                     vm.startingCity = response.data.city + ', ' + response.data.state;
                 })
                     .catch(function (error) {
                         vm.startingCity="Invalid Zipcode";
                     });
             }, 500),

 тут также используется метод _debounce(function, delay) - суть которого в том что он позволяет вызвать определенный метод
 через определенное количество миллисекунд, это нужно для того чтобы не произошли не предвиденные изменения, плюс для лучшего UI
 мы сначала пропишем в startingCity значение Searching..., чтобы пока идет запрос пользователь видел что что-то будет изменяться
}

















webformyself
v-html директива позволяет выводить и компилировать html код который может храниться как переменная

@click = "myFunction()" - возможность передавать функцие обаботчика событий
если мы хотим передать событие, то используем вот такой вот синтаксис:
@click = "myFunction($event)" - то есть $event зарезервированное имя для передачи события, можно включать не смотря на порядок

модификаторы события - это дополнительная возможность у директивы v-on, которая позволяет уменьшить код:
@click.prevent="testFunction()" - здесь prevent это модификатор
@mousemove.stop=" " - stop это укороченное название stopPropagation  которое останавливает обаботчик события
<!-- событие click не будет всплывать дальше -->
<a v-on:click.stop="doThis"></a>

<!-- событие submit больше не будет перезагружать страницу -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- модификаторы можно объединять в цепочки -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- и использовать без указания пользовательского обработчика -->
<form v-on:submit.prevent></form>

<!-- при добавлении слушателя события можно использовать capture mode -->
<!-- т.е. событие, нацеленное на внутренний элемент, обрабатывается здесь до обработки этим элементом -->
<div v-on:click.capture="doThis">...</div>

<!-- вызывать обработчик только в случае наступления события непосредственно -->
<!-- на данном элементе (то есть не на дочернем компоненте) -->
<div v-on:click.self="doThat">...</div>


у клавиатуры модификаторы таковы:
@keyup.enter.space./// = "myFunction", в данном случае данные модификаторы разряшают или запрещают обработку события пока не будет нажата данная клавиша
.enter
.tab
.delete (ловит как “Delete”, так и “Backspace”)
.esc
.space
.up
.down
.left
.right

также можно создать пользовательские клавиши:
// позволит использовать `v-on:keyup.f1`
Vue.config.keyCodes.f1 = 112, где 112 это keyCode у f1

Модификаторы формы:
<!-- синхронизируется после "change", а не "input" -->
<input v-model.lazy="msg" >



Классы:
Для динамического задания или удаления CSS-классов мы можем передать в директиву v-bind:class объект:

<div v-bind:class="{ active: isActive }"></div>
Запись выше обозначает, что наличие класса active будет определяться истинностью параметра isActive.

Таким образом можно управлять несколькими классами, добавляя в объект дополнительные поля. Кроме того, v-bind:class можно использовать и совместно с обычным атрибутом class:

<div class="static"
     v-bind:class="{ active: isActive, 'text-danger': hasError }">
</div>

При использовании этих данных:
data: {
  isActive: true,
  hasError: false
}

В v-bind:class можно передать и массив:

<div v-bind:class="[activeClass, errorClass]"></div>
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}


Для переключения классов, переданных в массиве, в зависимости от некоторого условия, можно использовать тернарный оператор:

<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
В этом случае errorClass будет применён к элементу всегда, а activeClass — только в случае истинности isActive.

Однако, такая запись становится слегка громоздкой, если у вас есть несколько классов, задаваемых по условию. Поэтому можно использовать и смешанный синтаксис:

<div v-bind:class="[{ active: isActive }, errorClass]"></div>


Inline стили:
Объектная запись для v-bind:style довольно проста — выглядит почти как CSS, хотя, на самом деле, это объект JavaScript. Для указания свойств CSS можно применять как camelCase, так и kebab-case (не забывайте про кавычки при использовании kebab-case):

<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
data: {
  activeColor: 'red',
  fontSize: 30
}
Передача объекта стилей по имени нередко может сделать код чище:

<div v-bind:style="styleObject"></div>
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
Разумеется, можно использовать и вычисляемые свойства, возвращающие объекты стилей.

Использование массивов
Запись v-bind:style с массивом позволяет применить несколько объектов стилей к одному и тому же элементу:

<div v-bind:style="[baseStyles, overridingStyles]"></div>


Условный рендеринг:
Как следует из названия, v-else-if служит в качестве “блока else if” для директивы v-if. Можно объединять эти директивы в длинные цепочки:

<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Не A/B/C
</div>
Подобно v-else, v-else-if должен непосредственно следовать за элементом с v-if или v-else-if.


v-if в сравнении с v-show
v-if производит “настоящий” условный рендеринг, удостоверяясь что подписчики событий и дочерние компоненты внутри блока должным образом уничтожаются и воссоздаются при изменении истинности управляющего условия.
v-if также ленив: если условие ложно на момент первоначального рендеринга, он не произведёт никаких действий — условный блок не будет отображён, пока условие впервые не станет истинным.
v-show, напротив, куда проще: элемент всегда присутствует в DOM, и только CSS-свойство переключается в зависимости от значения выражения.
В целом у v-if выше затраты на переключения, а у v-show более высокие затраты на первичный рендеринг. Так что если вы предполагаете, что переключения будут частыми, используйте v-show, если же редкими или вовсе маловероятными — v-if.





Внутри блока v-for нам полностью доступны свойства из области видимости родителя. v-for также поддерживает необязательный второй параметр для указания индекса текущего элемента.

<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Родитель',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})


v-for для объекта
v-for можно также использовать для итерирования по свойствам объекта:

<ul id="v-for-object" class="demo">
  <li v-for="value in object">
    {{ value }}
  </li>
</ul>
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      firstName: 'Иван',
      lastName: 'Петров',
      age: 30
    }
  }
})

Можно также указать второй аргумент для получения ключей:

<div v-for="(value, key) in object">
  {{ key }}: {{ value }}
</div>

И третий — для индексов:

<div v-for="(value, key, index) in object">
  {{ index }}. {{ key }}: {{ value }}
</div>

Рекомендуем указывать key с v-for по возможности всегда, за исключением случаев, когда итерируемый контент DOM прост, или когда вы сознательно используете стратегию по умолчанию для улучшения производительности.



Ref:
Доступ к экземплярам дочерних компонентов & элементов
Несмотря на наличие входных параметров и событий, иногда вам может потребоваться прямой доступ к дочернему компоненту в JavaScript. Для этого вы можете назначить ссылочный ID дочернему компоненту с помощью атрибута ref. Например:
<base-input ref="usernameInput"></base-input>
Теперь в компоненте, где вы определили этот ref, вы можете использовать:
this.$refs.usernameInput
для доступа к экземпляру <base-input>. Это может быть полезно, если вы хотите например, программно добавить фокус на поле из родителя. В этом случае компонент <base-input> может аналогичным образом использовать ref чтобы обеспечить доступ к определённым элементам внутри него, например:
<input ref="input">
И даже определить методы для использования родителем:
methods: {
  // Используется родителем для фокуса на input
  focus: function () {
    this.$refs.input.focus()
  }
}
Таким образом мы позволим родительскому компоненту добавлять фокус на input внутри <base-input> с помощью:
this.$refs.usernameInput.focus()
Когда ref используется вместе с v-for, то ref будет массивом, содержащим дочерние компоненты, отображаемых от источника данных.
$refs заполняются только после того, как компонент был отрендерен, и они не реактивны. Это подразумевается только как обходной путь для прямого манипулирования потомками — вам следует избегать доступа к $refs из шаблонов или вычисляемых свойств.




ref
Принимает: string
Название элемента или компонента для регистрации ссылки на него. В объекте $refs появится поле с названием из этого атрибута и значением: элементом DOM, если атрибут стоял на простом теге или экземпляром компонента, если атрибут стоял на пользовательском компоненте:
<!-- vm.$refs.p будет DOM-элементом -->
<p ref="p">hello</p>
<!-- vm.$refs.child будет указывать на экземпляр дочернего компонента -->
<child-component ref="child"></child-component>
При использовании на элементах/компонентах с v-for, регистрируется массив ссылок на элементы DOM или экземпляры компонентов.
Важное замечание о времени регистрации ссылок: поскольку ссылки создаются render-функцией, вы не сможете использовать их при первичном рендеринге — на тот момент они ещё не существуют! Кроме того, объект $refs не является реактивным, поэтому не стоит пытаться использовать его в шаблонах для связывания данных.



vm.$refs
Тип: Object
Только для чтения
Подробности:
Объект из DOM-элементов и экземпляров компонентов, зарегистрированных с помощью атрибутов ref.





vm.$mount( [elementOrSelector] )
Аргументы:
{Element | string} [elementOrSelector]
{boolean} [hydrating]
Возвращает: vm — сам экземпляр
Использование:
Если при создании экземпляра Vue не была указана опция el, он окажется в “непримонтированном” (unmounted) состоянии, то есть без ассоциированного элемента DOM. Вызовите vm.$mount(), чтобы примонтировать такой экземпляр.
Если параметр elementOrSelector не указан, шаблон будет отрендерен как элемент вне документа. Вы сможете затем вставить такой элемент нативным интерфейсом DOM.
Метод возвращает сам экземпляр, чтобы вы могли вызывать дополнительные методы по цепочке.
Пример:
var MyComponent = Vue.extend({
  template: '<div>Привет!</div>'
})
// создаём и монтируем в #app (заменит #app):
new MyComponent().$mount('#app')

// другой вариант записи, делает то же самое:
new MyComponent({ el: '#app' })

// рендерим вне документа и вставляем в DOM позднее:
var component = new MyComponent().$mount()
document.getElementById('app').appendChild(component.$el)


template
Тип: string

Подробности:

Строковый шаблон с разметкой для экземпляра Vue. Этот шаблон заменит элемент в точке монтирования. Вся уже существующая разметка в точке монтирования будет проигнорирована, если в шаблоне нет слота распределения контента.

Если строка начинается с #, она будет использована как querySelector, а в качестве строкового шаблона будет использован innerHTML элемента с указанным id. Так вы сможете включать шаблоны, из тегов вроде <script type="x-template">.

С точки зрения безопасности необходимо использовать только те шаблоны Vue, которым вы можете доверять. Никогда не используйте в качестве шаблона данные, вводимые пользователем.

Если в опциях Vue указана render-функция, шаблон будет проигнорирован.




Жизненный цикл:
beforeCreate: function(){
} - вызывается тогда когда происходит инициализация и vue готовится создать новое приложение

created: function(){
} - приложение будет создано

на выше описанных этапах html код еще не был создан

beforeMount: function(){
} - приложение начало анализировать шаблон и собирается вставить скомпилированный шаблон в DOM дерево

mounted: function(){
} - шаблон был вставлен в ДОМ дерево


beforeUpdate: function() {
} - цикл происходит перед изменением чего - либо

updated: function(){
} - цикл происходит после изменения

beforeDestroy: function(){
} - вызывается перед удалением обьекта
сам destroy вызывается через метод this.$destroy()

destroy: function(){
} - после уничтожения




Cli {
чтобы установить cli нужно сначала запустить команды
npm install -g @vue/cli
npm install -g @vue/cli-init

далее
vue init webpack-simple vue-project - где webpack-simple это template, а vue-project это имя проекта



render: - функция которая позволяетс запускать приложение,
внутри App.vue есть ES6 метод export default - который экспортирует обьект со всеми методами vue

}

Компоненты{
    lesson 1 {
        Components are one of the most powerful features of Vue.js.
        They help you extend basic HTML elements to encapsulate reusable code.
        At a high level, Components are custom elements that Vue.js’ compiler would attach specified behavior to.
        In some cases, they may also appear as a native HTML element extended with the special is attribute.

        для того чтобы создать компонент, нужно использовать метод у Vue:
        Vue.component('tag-name', {
            template: ``,
            data: function(){
                return {
                }
            }
        });
        где мы видим первым параметром компонент принимает название тега которвым он будет вызываться, второй параметр
        это обьект инициализации vue
        в нем обязательно должно быть свойство template - это и есть тот шаблон html который будет производиться вместо
        тегов

        data - здесь функция.
    }

    lesson 2 {
        data именно функция т.к. компоненты могут повторяться на странице, но их суть заключается в том что каждый из них должен быть идентичен.
        если мы будем использовать data к функция которая возвращает обьект, то мы получается регистрируем для каждого компонента
        свою персональную функцию которая будет возвращать данные именно для своего компонента. То есть javascript будет создавать новый обьект
        для каждого компонента.

        В случае когда мы используем обьект data то все переменные для этого обьекта будут едины для всех компонентов использующих данный обьект:

        var dataObj= {
            counter: 0
        }

        Vue.component..:
            data: dataObj

        и тогда если мы будем нажимать на кнопку add у разных компонентов, коунтер будет увеличиаваться у всех одновременно, т.к. все компоненты имеют доступ к одной переменной
    }


    lesson 3 {
        существует возможность регистрировать компоненты глобально и локально, в предудыщих 2 уроках мы регистрировали компонент глобально, но тут будем регать локально
        это делается для того чтобы если у нас существуют несколько приложений vue например app и app2, и у них могут быть компоненты с одинаковым названием но разным функционалом
        то глобально созданные компоненты не будут удобны.

        для локального создания мы можем в обьекте vue использовать свойство components :
        components: {
            'my-counter': {
                template: `
                    <div style="border:1px solid black; padding: 10px;">
                      <h2>Counter: {{counter}}</h2>
                      <button @click="add">Add</button>
                    </div>
                 `,
                data: function () {
                    return {
                        counter: 0
                    }
                },
                methods: {
                    add: function () {
                        this.counter++;
                    }
                }
            }
        }

        теперь соответственно в app2 vue не видит такой компонент как my-counter
    }

    lesson 4 {
        название компонентов инициализируется через строку как в уроке выше, но иногда это не возможно, поэтому ткаже возможно называть компоненты
        не в строковом формате, а используя camelCase, а vue сам распарсит и создатся тег в kebab-case:
        el: '#app2',
            components: {
                myCounter: {
                    template: `
                        <div style="border:1px solid black; padding: 10px;">
                          <h2>Counter: {{counter}}</h2>
                          <button @click="add">Add</button>
                        </div>
                     `,
                    data: function () {
                        return {
                            counter: 0
                        }
                    },
                    methods: {
                        add: function () {
                            this.counter++;
                        }
                    }
                }
        }
    }


    lesson 5  {
        переходим в cli vue-project

        создаем компонент Car.vue

        также можно зарегистрировать компоненты глобально и локально:
        глобально: в main.js импортируем данный компонент, и через метод Vue.component() создаем его:
            // import Car from './Car.vue'
            //
            // Vue.component('app-car', Car);

        локально: в App.vue импортируем опять таки компонент и в свойстве components добавляем данный компонент:
            import Car from './Car.vue'

            export default {
                data() {
                    return {
                        msg: 'Welcome'
                    }
                },
                components: {
                    appCar: Car
                }
            }
    }


    lesson 6 {
		чтобы передать какие то переменные в компоненты, мы сначала байндим название переменной к переменной в род компоненте
		у компонента:
		<app-car :carName="carName"></app-car>

		далее в дочернем компоненте добавим свойство props у него покажем что была передана переменная, props принимает
		массив из строк с названием переменных:
		 props: [
                    'carName'
         ],
    }

    lesson 7 {
		валидация передаваемых данных, в vue возможно валидировать данные на тип default, required и т.д.
		допустим мы передаем carName в дочерний компонент car.vue, но случайно он стал цифровым значением, но у нас есть
		в дочернем методе какой то функционал который работает со строками, для этого мы можем валидировать данные:
		создаем не массив, а обьект props у дочернего компонента, и у переменных добавляем обьект:
		props: {
            carName: {
                type: String,
                required: true,
                default: 'Toyota'
            },
            carYear: Number
        },
        как мы видим у carName мы проверяем является ли тип String, required и дефолт значение

        также можно валидировать просто на тип не через обьект а просто прописав как значение
    }

    lesson 8 {
		для того чтобы передать какие то значения или изменения с дочернего в родительский класс, нужно:
		1-сделать emit события у дочернего компонента:
		 <button @click="changeName">Изменить имя</button>
		в скрипте
		methods: {
            changeName: function () {
                this.carName='Mazda';
                this.$emit('nameChanged', this.carName);
            }
        } - тут мы видим что this.$emit('name', param) будет вызывать событие у род класса, и первым параметром принимает название
        события, вторым переменную которую надо передать

        2- нужно прослушивать данное событие у родительского компонента:
        @nameChanged="carName=$event/*changeName($event)*/"
        тут мы прослушиваем событие nameChanged и в нем присваиваем обьекту из род класса carName значение $event,
        которое и есть то самое значение которые передавалось с дочернего компонента
    }


	lesson 9 {
		также можно передавать функции с родительского в дочерний компонент
		для начала создадим метод в родительском App.vue:
		changeName: function () {
            this.carName = 'Audi';
        }

        далее байндим его в дочерний комп:
        :changeFunc="changeName" -  то есть будет создана переменная changeFunc которая будет методом

        проверим ее на валидность в дочернем компоненте в Props:
         changeFunc: Function

        и вызываем ее:
           <button @click="changeFunc">Изменить имя от родителя</button>
	}


	lesson 10 {
		взаимодействие между двумя дочерними компонентами:
		это можно сделать разными способами, тут сначала рассмотрим более сложный:

		допустим мы будем нажимать на кнопку в дочернем комп car и значение counter должно изменяться в counter:
		для этого сначала зарегистрируем новый компонент, далее пропишем в нем template и scripts:
		<template>
            <h1>Counter - {{counter}}</h1>
        </template>

        <script>
        export default {
            props: ['counter']
        }
        </script>

        далее создадим переменную counter в App.vue и будем передавать его в counter и car компоненты:
         <app-counter :counter="counter"></app-counter>
         :counter="counter"

         далее в car.vue пропишем button и method:
          <button @click="updateCounter">Добавить в счетчик</button>

          updateCounter: function () {
              this.$emit('counterUpdated', this.counter+1)
          }

          и соответственно будем прослушивать событие в app.vue:
            @counterUpdated="counter=$event"

			но если честно очень много логики
	}



	lesson 11 {
	проще метод, сначала в main.js созадим константу и будем ее экспортировать:
	export const eventEmiter = new Vue()
	данная переменная нужна как инициализатор события

	импортируем его в Counter.vue и Car.vue:
	import {eventEmitter} from "./main";

	далее в копм. Car изменим метод updateCounter:
	    updateCounter: function () {
            eventEmitter.$emit('counterUpdated', 3);
        }- тут мы также через метод $emit вызываем событие 'counterUpdated' и также можем передать какие то значения вторым параметром

    теперь в комп counter будем прослушивать данное событие:
	    created(){
	        eventEmitter.$on('counterUpdated', (num) => {
	            if(num){
	                this.counter+=num;
	            }
	            else {
	                this.counter++;
	            }
	        })
	    } - тут мы с помощью метода $on прослушиваем событие 'counterUpdated' и ждем получение аттрибута в функции,
	    данная функция как раз и будет выполнять обработчик события
	}



	lesson 12 {
		все стили глобальные и если мы пропишем стиль для одного компонента и также будет использовать такое же название классов или
		стиль по тегам то эти стили будут относиться ко всему шаблону

		чтобы этого избежать достаточно просто добавить такой аттрибут как scoped к style:
		<style scoped>
            h2 {
                color: red;
            }
        </style> - все теперь данный стиль будет относиться только к своему дочернему обьекту
	}

	lesson 13 {
		также в дочерние компоненты мы можем передавать html код для этого мы можем прям внутрь компонента прописать html код App.vue:
		<app-car>
			<h2> Hello </h2>
		</app-car>

		 но для того чтобы дочерний видел мы должны добавить такой тег который vue сам читает Car.vue:
		 <div>
		    <slot></slot>
		 </div>

		 также мы можем с род комп спокойно передавать переменные App.vue:
		  <h2>Mazda + {{carName}}</h2>

		  также все стили прописанные в род комп будут работать для этого html кода в дочернем комп-те
		  и наоборот все дочерние стили будут работать на передаваемом шаблоне от род компа

		  также мы можем определять расположение тех или иных слотов, для этого нужно в Car.vue добавить аттр name:
		   <slot name="h2"></slot>
          <hr>
          <hr>
          <slot name="p"></slot>

          а в App.vue добавить аттр slot:
          <h2 slot="h2">Mazda + {{carName}}</h2>
          <p slot="p">test</p>
	}
  }



  Директивы {
  lesson 1 {
    создание собственной директивы

	для того чтобы создать директиву нужно:
	1 - создаем файл в src в котором будем описывать эту директиву, пример color.js:
	export default {

    }

    2 - импортируем ее в main.js и с помощью метода Vue.directive(name, objectDescription) инициализируем ее:
    import ColorDirective from 'color.js'

    Vue.directive('colored', ColorDirective);
    new Vue({
      el: '#app',
      render: h => h(App)
    })
  }


  lesson 2 {
	директива это обьект, и первый метод при ее инициализации это метод bind(el, bindings, vnode){}
	где el - элемент к которому добавляется директива, bindings - содержит все свойства которые будем передавать внутрь директивы: значение, имя и т.д.
	vnode - обьект хранящий место где будет храниться директива. Последние два параметра readonly:

	сам bind() описываем :
	 bind(el, bindings, vnode) {
            // el.style.color = 'red';
            el.style.color = 'blue';
    }

    и инициализируем директиву внутри vue компонента:
        <h2 v-colored>{{msg}}</h2>
  }


  lesson 3 {
  жизненный цикл:
    bind(el, bindings, vnode) - инициализируется и прикрепляется к виртуальному DOM, но еще не в реальном DOM
    inserted(el, bindings, vnode) - директива уже добавлена в реальное DOM
    update(el, bindings, vnode, oldvnode) - вызывается когда что то происходит внутри DOM дерева
	componentUpdated(el, bindings, vnode, oldvnode) - вызывается сразу после update если были изменены дочерние элементы
	unbind() - когда директива убирается из DOM или прекращает существ
  }

  lesson 4 {
  передача переменных:
	для того чтобы передавать значения в директивы можно просто в кавычках прописать значение:
	<h2 v-colored="'green'">{{msg}}</h2> в нашем случае мы передаем цвет green

	и в цикле bind() получить это значение:
	el.style.color = bindings.value;

	то есть через bindings параметр мы можем получить доступ к переменныи передаваемым в директивы
  }

  lesson 5 {
  передача аргументов директивы:
  аргументом называется вот такая конструкция:
  <button v-on:click> - аргумент идет после : и называется click

	чтобы получить доступ мы в обьекте директивы прописываем:
	 bind(el, bindings, vnode) {
        const argument = bindings.arg; // получаем как раз слово после : background или color
        el.style[argument] = bindings.value;
     },

     и в самом шаблоне:
     <h2 v-colored:background="'green'">{{msg}}</h2>
     <h2 v-colored:color="'blue'">{{msg}}</h2>
  }

  lesson 6 {
    модификаторы:
    <button v-on:click.prevent> - где prevent это и есть модификатор

	создадим в шаблоне такие модификаторы:
	 <h2 v-colored:background.font="'green'">{{msg}}</h2>
        <h2 v-colored:color.delay.font="'blue'">{{msg}}</h2>

    все модификаторы приходят в параметр bindings.modifiers:
   const fontModifier = bindings.modifiers['font']; //так мы получаем модификаторы переданные в директиву, получает либо true либо false

	далее мы проверяем если есть или нет данной переменной мы прописываем логику:
	if(fontModifier){
        el.style.fontSize ='30px'
    }
  }

  lesson 7 {
     локальная инициализация:
     можно инициализировать директивы внутри компонентов через:
     directives: {
		font: {
		bind(el,bindings, vnode){
		el.style.fontSize = '40px'
		}
		}
     }
		так можно инициализировать
     <h2 v-font>Local directive</h2>
  }
  }

Фильтры и миксины{
    Фильтры это специальные трансформеры которые позволяют нам преобразовывать отображение каких либо строк или элементов:

    регистрировать фильтры можно глобально и локально:
    глобально в main.js обращаемся к Vue инстансу и создаем фильтр через метод filter, где первым параметром пишем название
    а вторым мы пишем ФУНКЦИЮ которое получает какое то исходное значение которое нужно будет преобразовать, в нашем случае
    мы преобразуем value в верхний регистр:
    Vue.filter('uppercase', value=>value.toUpperCase());

    для локального создания в свойстве filters создаем функцию опять таки как выше:
    filters: {
    lowercase(value) {
       return value.toLowerCase();
        }
    }

    вызываются фильтры в template через вертикальную черту, где перед чертой то значение которое нужно преобразовать:
    <h1>{{ msg | lowercase }}</h1>
    <h1>{{ msg | uppercase }}</h1>

    также есть возможность применять фильтры несколько раз:
    <h1>{{ msg | uppercase | lowercase}}</h1>

Фильтрация списков:
        для того чтобы фильтровать списки есть достаточно простой способ:

        создаем массив фруктов и стринговое поле search:
         fruits: ['apple', 'banana', 'orange', 'peach'],
        search: ''

        далее отображаем в шаблоне:
        <input type="text" v-model="search">
        <ul>
            <li v-for="fruit in filteredFruits">{{fruit}}</li>
        </ul>

        то есть у нас есть input search в котором мы ищем фрукт и есть список всех фруктов соответствующих поиску,
        но filteredFruits это computed метод, в нем и просходит сравнение и т.д.:
        computed: {
            filteredFruits(){
                return this.fruits.filter(fruit=>{
                    return fruit.toLowerCase().indexOf(this.search.toLowerCase()) !== -1
                })
            }
        }


Миксины:
        Миксины это инстансы vue которые можно использовать для исключения повторения кода, бывают случаи когда код нужно
        дублировать, но вместо тупо копипастинга можно использовать mixin:

        1 - локально: создаем файл listMixin.js и туда вставляем код который хотим чтобы дублировался:
        export default {
            data() {
                return {
                    fruits: ['apple', 'banana', 'orange', 'peach'],
                    search: ''
                }
            },
            computed: {
                filteredFruits(){
                    return this.fruits.filter(fruit=>{
                        return fruit.toLowerCase().indexOf(this.search.toLowerCase()) !== -1
                    })
                }
            }
        }

        в компонентах регистрируем mixin, сначала импортируем и потом в свойстве mixins: [] в массив добавляем тот обьект:
           import ListMixin from './listMixin.js'
           mixins: [ListMixin]

        Важно заметить внутри файла обьекта можно использовать абсолютно весь функционал Vue и если значения из миксинов и компонентов
        повторяются то сначала будет производиться значения из компонента а потом из миксина:
         data() {
            return {
                msg: 'Welcome to Your Vue.js App',
            }
         },
          mixins: [ListMixin]

          глобально создается через метод:
          Vue.mixin({
              beforeCreate(){
                console.log('beforecreate')
              }
          })
}




